theory burrito begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: fst/1, h/1, pair/2, pk/1, sdec/2, senc/2, sign/2, snd/1,
           true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true



rule (modulo E) Intel_RoT_Initialize[color=#ffbf00]:
   [ Fr( ~intel_rot_ltk ) ]
  --[ Intel_RoT_Initialize( ), Intel_RoT_Key( ~intel_rot_ltk ) ]->
   [
   Out( pk(~intel_rot_ltk) ), !Intel_RoT_Pk( pk(~intel_rot_ltk) ),
   !Intel_RoT_Ltk( ~intel_rot_ltk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Intel_RoT_Certify[color=#ffbf00]:
   [
   QE_CSR( ~ppid, platform_data, qek_pk ), !Intel_RoT_Ltk( ~intel_rot_ltk )
   ]
  --[
  Intel_RoT_Certify( <<'sgx_cert', qek_pk, ~ppid>, 
                      sign(<'sgx_cert', qek_pk, ~ppid>, ~intel_rot_ltk)>
  )
  ]->
   [
   Out( <<'sgx_cert', qek_pk, ~ppid>, 
         sign(<'sgx_cert', qek_pk, ~ppid>, ~intel_rot_ltk)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SGX_QE_Initialize[color=#e83f6f]:
   [ Fr( ~ppid ), Fr( ~qe_ltk ) ]
  --[ SGX_QE_Initialize( ), SGX_QE_Ltk( ~ppid, ~qe_ltk ) ]->
   [
   Out( ~ppid ), Out( ~ppid ), Out( pk(~qe_ltk) ),
   QE_CSR( ~ppid, ~ppid, pk(~qe_ltk) ), !QE_Ltk( ~ppid, ~ppid, ~qe_ltk ),
   !SGX_Platform_Initialied( ~ppid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SGX_QE_Generate_Quote[color=#e83f6f]:
   [
   !QE_Ltk( ~ppid, platform_data, ~qe_ltk ),
   Quote_Request( ~ppid, $measurement, report_data )
   ]
  --[
  SGX_QE_Generate_Quote( <
                          <'sgx_quote', $measurement, platform_data, report_data>, 
                          sign(<'sgx_quote', $measurement, platform_data, report_data>, ~qe_ltk)>
  )
  ]->
   [
   Out( <<'sgx_quote', $measurement, platform_data, report_data>, 
         sign(<'sgx_quote', $measurement, platform_data, report_data>, ~qe_ltk)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) AMD_RoT_Initialize[color=#32936f]:
   [ Fr( ~amd_rot_ltk ) ]
  --[ AMD_RoT_Initialize( ), AMD_RoT_Key( ~amd_rot_ltk ) ]->
   [
   Out( pk(~amd_rot_ltk) ), !AMD_RoT_Pk( pk(~amd_rot_ltk) ),
   !AMD_RoT_Ltk( ~amd_rot_ltk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) AMD_RoT_Certify[color=#32936f]:
   [ PSP_CSR( ~cpu_id, psp_sn_pk ), !AMD_RoT_Ltk( ~amd_rot_ltk ) ]
  --[
  AMD_RoT_Certify( <<'sev_cert', psp_sn_pk>, 
                    sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)>
  )
  ]->
   [
   Out( <<'sev_cert', psp_sn_pk>, 
         sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SEV_PSP_Initialize[color=#2a848a]:
   [ Fr( ~cpu_id ), Fr( ~psp_sn ) ]
  --[ SEV_PSP_Initialize( ), SEV_PSP_Ltk( ~cpu_id, ~psp_sn, 'g'^~psp_sn )
  ]->
   [
   Out( 'g'^~psp_sn ), PSP_CSR( ~cpu_id, 'g'^~psp_sn ),
   !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, 'g'^~psp_sn )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SEV_PSP_Initialize_Guest[color=#2a848a]:
   [
   In( <go_sn_pk, 
        senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', go_sn_pk^~psp_sn>)), 
        h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', go_sn_pk^~psp_sn>)>), 
        $vm_dig>
   ),
   !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, psp_sn_pk ),
   Fr( ~mnonce )
   ]
  --[ SEV_PSP_Initialize_Guest( ) ]->
   [
   SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik, $vm_dig,
                              h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
   ),
   Out( <~mnonce, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)> )
   ]

  /*
  rule (modulo AC) SEV_PSP_Initialize_Guest[color=#2a848a]:
     [
     In( <go_sn_pk, senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>)), 
          h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', z>)>), $vm_dig>
     ),
     !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, psp_sn_pk ),
     Fr( ~mnonce )
     ]
    --[ SEV_PSP_Initialize_Guest( ) ]->
     [
     SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik, $vm_dig,
                                h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
     ),
     Out( <~mnonce, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)> )
     ]
    variants (modulo AC)
    1. ~psp_sn
             = ~psp_sn.16
       go_sn_pk
             = go_sn_pk.19
       z     = go_sn_pk.19^~psp_sn.16
    
    2. ~psp_sn
             = ~psp_sn.20
       go_sn_pk
             = z.27^inv(~psp_sn.20)
       z     = z.27
    
    3. ~psp_sn
             = ~psp_sn.44
       go_sn_pk
             = x.82^x.83
       z     = x.82^(~psp_sn.44*x.83)
    
    4. ~psp_sn
             = ~psp_sn.47
       go_sn_pk
             = x.88^inv((~psp_sn.47*x.89))
       z     = x.88^inv(x.89)
    
    5. ~psp_sn
             = ~psp_sn.47
       go_sn_pk
             = x.88^(x.89*inv(~psp_sn.47))
       z     = x.88^x.89
    
    6. ~psp_sn
             = ~psp_sn.48
       go_sn_pk
             = x.89^(x.90*inv((~psp_sn.48*x.91)))
       z     = x.89^(x.90*inv(x.91))
  */

rule (modulo E) SEV_PSP_Launch_Guest[color=#2a848a]:
   [
   In( <senc(<'launch_secret', measure, ~guest_secret>, ~tek), 
        h(<<'launch_secret', measure, ~guest_secret>, ~tik>)>
   ),
   SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik, $vm_dig,
                              measure
   )
   ]
  --[
  SEV_PSP_Launch_Guest( ),
  SEV_PSP_Secrets( psp_sn_pk, ~tik, ~guest_secret )
  ]->
   [ !SEV_PSP_Guest_Running( ~cpu_id, psp_sn_pk, $vm_dig, ~guest_secret ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TO_Enclave_Verify_Platform_Cert[color=#2274a5]:
   [
   !AMD_RoT_Pk( pk(~amd_rot_ltk) ),
   In( <<'sev_cert', psp_sn_pk>, sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)
       >
   )
   ]
  --[
  TO_Enclave_Verify_Platform_Cert( <<'sev_cert', psp_sn_pk>, 
                                    sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)>
  )
  ]->
   [ Platform_PK_Verified( psp_sn_pk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TO_Enclave_Deploy_VM[color=#2274a5]:
   [
   !SGX_Platform_Initialied( ~ppid ), Platform_PK_Verified( psp_sn_pk ),
   In( $vm_dig ), Fr( ~go_sn ), Fr( ~tek ), Fr( ~tik )
   ]
  --[
  TO_Enclave_Deploy_VM( ),
  TO_Enclave_Secrets( psp_sn_pk, psp_sn_pk^~go_sn,
                      h(<'sev_kek', psp_sn_pk^~go_sn>), h(<'sev_kik', psp_sn_pk^~go_sn>), ~tek,
                      ~tik
  )
  ]->
   [
   Out( <'g'^~go_sn, 
         senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', psp_sn_pk^~go_sn>)), 
         h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', psp_sn_pk^~go_sn>)>), 
         $vm_dig>
   ),
   TO_Enclave_VM_Deployed( psp_sn_pk, ~ppid, ~tek, ~tik, $vm_dig )
   ]

  /*
  rule (modulo AC) TO_Enclave_Deploy_VM[color=#2274a5]:
     [
     !SGX_Platform_Initialied( ~ppid ), Platform_PK_Verified( psp_sn_pk ),
     In( $vm_dig ), Fr( ~go_sn ), Fr( ~tek ), Fr( ~tik )
     ]
    --[
    TO_Enclave_Deploy_VM( ),
    TO_Enclave_Secrets( psp_sn_pk, z, h(<'sev_kek', z>), h(<'sev_kik', z>),
                        ~tek, ~tik
    )
    ]->
     [
     Out( <'g'^~go_sn, 
           senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>)), 
           h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', z>)>), $vm_dig>
     ),
     TO_Enclave_VM_Deployed( psp_sn_pk, ~ppid, ~tek, ~tik, $vm_dig )
     ]
    variants (modulo AC)
    1. ~go_sn
             = ~go_sn.16
       psp_sn_pk
             = psp_sn_pk.20
       z     = psp_sn_pk.20^~go_sn.16
    
    2. ~go_sn
             = ~go_sn.20
       psp_sn_pk
             = z.28^inv(~go_sn.20)
       z     = z.28
    
    3. ~go_sn
             = ~go_sn.85
       psp_sn_pk
             = x.166^x.167
       z     = x.166^(~go_sn.85*x.167)
    
    4. ~go_sn
             = ~go_sn.89
       psp_sn_pk
             = x.174^inv((~go_sn.89*x.175))
       z     = x.174^inv(x.175)
    
    5. ~go_sn
             = ~go_sn.89
       psp_sn_pk
             = x.174^(x.175*inv(~go_sn.89))
       z     = x.174^x.175
    
    6. ~go_sn
             = ~go_sn.90
       psp_sn_pk
             = x.175^(x.176*inv((~go_sn.90*x.177)))
       z     = x.175^(x.176*inv(x.177))
  */

rule (modulo E) TO_Enclave_Provision_VM[color=#2274a5]:
   [
   TO_Enclave_VM_Deployed( psp_sn_pk, ~ppid, ~tek, ~tik, $vm_dig ),
   In( <~mnonce, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)> ),
   Fr( ~cik )
   ]
  --[
  TO_Enclave_Provision_VM( psp_sn_pk, ~cik, $vm_dig ),
  TO_Enclave_Guest_Secrets( psp_sn_pk, ~tik, ~cik )
  ]->
   [
   Out( <
         senc(<'launch_secret', 
               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik>,
              ~tek), 
         h(<
            <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
            >, 
            ~tik>)
        >
   ),
   TO_Enclave_VM_Provisioned( psp_sn_pk, ~ppid, <~mnonce, $vm_dig>, ~cik )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) TO_Enclave_Generate_Report_For_VM[color=#2274a5]:
   [
   TO_Enclave_VM_Provisioned( psp_sn_pk, ~ppid, msr, ~cik ),
   In( <vm_data, h(<'report_request', vm_data, ~cik>)> )
   ]
  --[ TO_Enclave_Generate_Report_For_VM( ~ppid, psp_sn_pk, msr, vm_data )
  ]->
   [
   Quote_Request( ~ppid, 'burrito_enclave_sgx_measurement',
                  h(<'report_data', psp_sn_pk, msr, vm_data>)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Guest_VM_Request_Report[color=#4c5454]:
   [
   !SEV_PSP_Guest_Running( ~cpu_id, psp_sn_pk, 'burrito_guest_vm', ~cik ),
   Fr( ~timestamp )
   ]
  --[ Guest_VM_Request_Report( psp_sn_pk, ~timestamp ) ]->
   [
   Out( <<'burrito_report', ~timestamp>, 
         h(<'report_request', <'burrito_report', ~timestamp>, ~cik>)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) RP_Verify_Quote[color=#99c9b7]:
   [
   !Intel_RoT_Pk( pk(~intel_rot_ltk) ),
   In( <
        <<'sgx_quote', $measurement, ~ppid, report_data>, 
         sign(<'sgx_quote', $measurement, ~ppid, report_data>, ~qe_ltk)>, 
        <'sgx_cert', pk(~qe_ltk), ~ppid>, 
        sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)>
   )
   ]
  --[
  RP_Verify_Quote( <'sgx_quote', $measurement, ~ppid, report_data> ),
  RP_QE_Ltk( ~qe_ltk, ~ppid )
  ]->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_Intel_RoT[color=#f5b7b1]:
   [ !Intel_RoT_Ltk( ~intel_rot_ltk ) ]
  --[ Compromise_Intel_RoT( ) ]->
   [ Out( ~intel_rot_ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_SGX_QE[color=#f5b7b1]:
   [ !QE_Ltk( ~ppid, platform_data, ~qe_ltk ) ]
  --[ Compromise_SGX_QE( ~ppid ) ]->
   [ Out( ~qe_ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Adversary_Request_Quote[color=#f5b7b1]:
   [ In( <~ppid, $sgx_measurement, report_data> ) ]
  --[
  Neq( $sgx_measurement, 'burrito_enclave_sgx_measurement' ),
  Adversary_Request_Quote( )
  ]->
   [ Quote_Request( ~ppid, $sgx_measurement, report_data ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_AMD_RoT[color=#f5b7b1]:
   [ !AMD_RoT_Ltk( ~amd_rot_ltk ) ]
  --[ Compromise_AMD_RoT( ) ]->
   [ Out( ~amd_rot_ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_SEV_PSP[color=#f5b7b1]:
   [ !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, psp_pk ) ]
  --[ Compromise_SEV_PSP( psp_pk ) ]->
   [ Out( ~psp_sn ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Adversary_Extract_SEV_Secret[color=#f5b7b1]:
   [ !SEV_PSP_Guest_Running( ~cpu_id, psp_sn_pk, $vm_dig, ~guest_secret ) ]
  --[
  Neq( $vm_dig, 'burrito_guest_vm' ),
  Adversary_Extract_SEV_Secret( $vm_dig, ~guest_secret )
  ]->
   [ Out( ~guest_secret ) ]

  /* has exactly the trivial AC variant */

restriction Inequality:
  "∀ x #i. (Neq( x, x ) @ #i) ⇒ (⊥)"
  // safety formula

restriction Intel_RoT_Initializes_Once:
  "∀ #i #j.
    ((Intel_RoT_Initialize( ) @ #i) ∧ (Intel_RoT_Initialize( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction AMD_RoT_Initializes_Once:
  "∀ #i #j.
    ((AMD_RoT_Initialize( ) @ #i) ∧ (AMD_RoT_Initialize( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

lemma lm_sev_amd_rot_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ltk #i.
    (AMD_RoT_Key( ltk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk #i.
  (AMD_RoT_Key( ltk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧ (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !KU( ~amd_rot_ltk ) @ #j )
  case Adversary_Extract_SEV_Secret
  solve( !KU( senc(<'launch_secret', 
                    h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~amd_rot_ltk>,
                   ~tek)
         ) @ #vk.1 )
    case c_senc
    by contradiction /* cyclic */
  qed
next
  case Compromise_AMD_RoT
  by contradiction /* from formulas */
qed

lemma lm_sev_psp_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ cpuid ltk ltk_pk #i.
    (SEV_PSP_Ltk( cpuid, ltk, ltk_pk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_SEV_PSP( ltk_pk ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ cpuid ltk ltk_pk #i.
  (SEV_PSP_Ltk( cpuid, ltk, ltk_pk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧
  (∀ #j. (Compromise_SEV_PSP( ltk_pk ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !KU( ~psp_sn ) @ #j )
  case Adversary_Extract_SEV_Secret
  solve( !KU( senc(<'launch_secret', 
                    h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~psp_sn>,
                   ~tek)
         ) @ #vk.1 )
    case c_senc
    by contradiction /* cyclic */
  qed
next
  case Compromise_SEV_PSP
  by contradiction /* from formulas */
qed

lemma lm_sev_enclave_secrets_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ k ss kek kik tek tik #i.
    (TO_Enclave_Secrets( k, ss, kek, kik, tek, tik ) @ #i) ⇒
    (((((((¬(∃ #j. !KU( ss ) @ #j)) ∧ (¬(∃ #j. !KU( kek ) @ #j))) ∧
         (¬(∃ #j. !KU( kik ) @ #j))) ∧
        (¬(∃ #j. !KU( tek ) @ #j))) ∧
       (¬(∃ #j. !KU( tik ) @ #j))) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k ss kek kik tek tik #i.
  (TO_Enclave_Secrets( k, ss, kek, kik, tek, tik ) @ #i)
 ∧
  (((∃ #j. (!KU( ss ) @ #j)) ∨
    (∃ #j. (!KU( kek ) @ #j)) ∨
    (∃ #j. (!KU( kik ) @ #j)) ∨
    (∃ #j. (!KU( tek ) @ #j)) ∨
    (∃ #j. (!KU( tik ) @ #j)))) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ #j. (!KU( ss ) @ #j))  ∥
       (∃ #j. (!KU( h(<'sev_kek', ss>) ) @ #j))  ∥
       (∃ #j. (!KU( h(<'sev_kik', ss>) ) @ #j))  ∥ (∃ #j. (!KU( ~tek ) @ #j))  ∥
       (∃ #j. (!KU( ~tik ) @ #j)) )
  case case_1
  solve( splitEqs(0) )
    case split_case_1
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( k ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( k^~go_sn ) @ #j )
          case TO_Enclave_Deploy_VM
          solve( !KU( sign(<'sev_cert', 'g'>, ~amd_rot_ltk) ) @ #vk.5 )
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_exp
          solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.5 )
            case AMD_RoT_Certify
            by contradiction /* non-normal terms */
          next
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_2
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( ss^inv(~go_sn) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ss^inv(~go_sn) ) @ #vk.4 )
          case c_exp
          solve( !KU( sign(<'sev_cert', ss^inv(~go_sn)>, ~amd_rot_ltk) ) @ #vk.5 )
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_3
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^x.1 ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( x^(~go_sn*x.1) ) @ #j )
          case AMD_RoT_Certify_case_1
          solve( !KU( 'g'^~x ) @ #vk.4 )
            case AMD_RoT_Certify
            solve( !KU( sign(<'sev_cert', 'g'^~x>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~go_sn ) @ #vk.6 )
                  case Adversary_Extract_SEV_Secret
                  solve( (∀ #j. (!KU( ~x ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~x ) @ #j)) )
                    case case_1
                    solve( !KU( senc(<'launch_secret', 
                                      h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                     ~tek.1)
                           ) @ #vk.8 )
                      case c_senc
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^~x>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~go_sn ) @ #vk.6 )
                  case Adversary_Extract_SEV_Secret
                  solve( (∀ #j. (!KU( ~x ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~x ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case AMD_RoT_Certify_case_2
          solve( !KU( 'g'^(~psp_sn*x) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x)>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x)>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case SEV_PSP_Initialize_case_1
          solve( !KU( 'g'^~x ) @ #vk.4 )
            case SEV_PSP_Initialize
            solve( !KU( sign(<'sev_cert', 'g'^~x>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~go_sn ) @ #vk.6 )
                  case Adversary_Extract_SEV_Secret
                  solve( (∀ #j. (!KU( ~x ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~x ) @ #j)) )
                    case case_1
                    solve( !KU( senc(<'launch_secret', 
                                      h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                     ~tek.1)
                           ) @ #vk.8 )
                      case c_senc
                      by contradiction /* cyclic */
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^~x>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~go_sn ) @ #vk.6 )
                  case Adversary_Extract_SEV_Secret
                  solve( (∀ #j. (!KU( ~x ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~x ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case SEV_PSP_Initialize_case_2
          solve( !KU( 'g'^(~psp_sn*x) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1)>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x)>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x)>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM_case_1
          solve( !KU( 'g'^~x ) @ #vk.5 )
            case TO_Enclave_Deploy_VM
            solve( !KU( sign(<'sev_cert', 'g'^~x>, ~amd_rot_ltk) ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^~x>, ~amd_rot_ltk) ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM_case_2
          solve( !KU( 'g'^(~go_sn*x) ) @ #vk.5 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x)>, ~amd_rot_ltk) ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x)>, ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x)>, ~amd_rot_ltk) ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x)>, ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x)>, ~amd_rot_ltk) ) @ #vk.8 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*~go_sn.1)>, ~amd_rot_ltk)
                   ) @ #vk.8 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM_case_3
          solve( !KU( 'g'^x ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~psp_sn ) @ #vk.6 )
                  case Adversary_Extract_SEV_Secret
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case Compromise_SEV_PSP
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~psp_sn ) @ #vk.6 )
                  case Adversary_Extract_SEV_Secret
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case Compromise_SEV_PSP
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^x>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~psp_sn ) @ #vk.6 )
                  case Adversary_Extract_SEV_Secret
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case Compromise_SEV_PSP
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case c_exp
          solve( !KU( x^x.1 ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~go_sn ) @ #vk.8 )
                  case Adversary_Extract_SEV_Secret
                  solve( !KU( ~psp_sn ) @ #vk.9 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~go_sn ) @ #vk.8 )
                  case Adversary_Extract_SEV_Secret
                  solve( !KU( ~psp_sn ) @ #vk.9 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^x.1>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( ~go_sn ) @ #vk.8 )
                  case Adversary_Extract_SEV_Secret
                  solve( !KU( ~psp_sn ) @ #vk.9 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_4
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^inv((~go_sn*x.1)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( x^inv(x.1) ) @ #j )
          case c_exp
          solve( !KU( x^inv((~go_sn*x.1)) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', x^inv((~go_sn*x.1))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_5
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv(~go_sn)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( x^x.1 ) @ #j )
          case AMD_RoT_Certify_case_1
          solve( !KU( 'g'^(~psp_sn*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case AMD_RoT_Certify_case_2
          solve( !KU( 'g'^(~psp_sn*x*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case SEV_PSP_Initialize_case_1
          solve( !KU( 'g'^(~psp_sn*inv(~go_sn)) ) @ #vk.4 )
            case SEV_PSP_Initialize
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case SEV_PSP_Initialize_case_2
          solve( !KU( 'g'^(~psp_sn*x*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv(~go_sn))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM_case_1
          solve( !KU( 'g'^(~go_sn*inv(~go_sn.1)) ) @ #vk.5 )
            case TO_Enclave_Deploy_VM
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*inv(~go_sn.1))>, ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*inv(~go_sn.1))>, ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM_case_2
          solve( !KU( 'g'^(~go_sn*x*inv(~go_sn.1)) ) @ #vk.5 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.8 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*~go_sn.1*inv(~go_sn.2))>,
                             ~amd_rot_ltk)
                   ) @ #vk.8 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case c_exp
          solve( !KU( x^(x.1*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_6
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv((~go_sn*x.2))) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( x^(x.1*inv(x.2)) ) @ #j )
          case AMD_RoT_Certify_case_1
          solve( !KU( 'g'^(~x*inv((~go_sn*x.1))) ) @ #vk.4 )
            case AMD_RoT_Certify
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case AMD_RoT_Certify_case_2
          solve( !KU( 'g'^(~psp_sn*x*inv((~go_sn*x.1))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv((~go_sn*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv((~go_sn*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv((~go_sn.1*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case SEV_PSP_Initialize_case_1
          solve( !KU( 'g'^(~x*inv((~go_sn*x.1))) ) @ #vk.4 )
            case SEV_PSP_Initialize
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case SEV_PSP_Initialize_case_2
          solve( !KU( 'g'^(~psp_sn*x*inv((~go_sn*x.1))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv((~go_sn*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*~psp_sn.1*inv((~go_sn*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*~x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv((~go_sn.1*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM_case_1
          solve( !KU( 'g'^(~x*inv((~go_sn*x.1))) ) @ #vk.5 )
            case TO_Enclave_Deploy_VM
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM_case_2
          solve( !KU( 'g'^(~go_sn*x*inv((~go_sn.1*x.1))) ) @ #vk.5 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv((~go_sn.1*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~psp_sn*x*inv((~go_sn.1*x.1)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*~x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.8 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*~go_sn.1*inv((x.1*~go_sn.2)))
                             >,
                             ~amd_rot_ltk)
                   ) @ #vk.8 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_3
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.7 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case c_exp
          solve( !KU( x^(x.1*inv((~go_sn*x.2))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv((~go_sn*x.2)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
next
  case case_2
  solve( splitEqs(0) )
    case split_case_1
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( k ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kek', k^~go_sn>) ) @ #j )
          case c_h
          solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.5 )
            case AMD_RoT_Certify
            by contradiction /* non-normal terms */
          next
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_2
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( ss^inv(~go_sn) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kek', ss>) ) @ #j )
          case c_h
          solve( !KU( ss^inv(~go_sn) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', ss^inv(~go_sn)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_3
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^x.1 ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j )
          case c_h
          solve( !KU( x^x.1 ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.8 )
                  case AMD_RoT_Certify
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( ~go_sn ) @ #vk.9 )
                      case Adversary_Extract_SEV_Secret
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                       ~tek.1)
                             ) @ #vk.11 )
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case TO_Enclave_Deploy_VM
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case c_exp
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.8 )
                  case SEV_PSP_Initialize
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( ~go_sn ) @ #vk.9 )
                      case Adversary_Extract_SEV_Secret
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                       ~tek.1)
                             ) @ #vk.11 )
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case TO_Enclave_Deploy_VM
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case c_exp
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^x.1>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.8 )
                  case AMD_RoT_Certify
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                next
                  case SEV_PSP_Initialize
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                next
                  case TO_Enclave_Deploy_VM
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                next
                  case c_exp
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_4
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^inv((~go_sn*x.1)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j )
          case c_h
          solve( !KU( x^inv((~go_sn*x.1)) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', x^inv((~go_sn*x.1))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_5
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv(~go_sn)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kek', x^x.1>) ) @ #j )
          case c_h
          solve( !KU( x^(x.1*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_6
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv((~go_sn*x.2))) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j )
          case c_h
          solve( !KU( x^(x.1*inv((~go_sn*x.2))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv((~go_sn*x.2)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
next
  case case_3
  solve( splitEqs(0) )
    case split_case_1
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( k ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kik', k^~go_sn>) ) @ #j )
          case c_h
          solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.5 )
            case AMD_RoT_Certify
            by contradiction /* non-normal terms */
          next
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_2
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( ss^inv(~go_sn) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kik', ss>) ) @ #j )
          case c_h
          solve( !KU( ss^inv(~go_sn) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', ss^inv(~go_sn)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_3
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^x.1 ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j )
          case c_h
          solve( !KU( x^x.1 ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.8 )
                  case AMD_RoT_Certify
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( ~go_sn ) @ #vk.9 )
                      case Adversary_Extract_SEV_Secret
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                       ~tek.1)
                             ) @ #vk.11 )
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case TO_Enclave_Deploy_VM
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case c_exp
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.8 )
                  case SEV_PSP_Initialize
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( ~go_sn ) @ #vk.9 )
                      case Adversary_Extract_SEV_Secret
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                       ~tek.1)
                             ) @ #vk.11 )
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case TO_Enclave_Deploy_VM
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case c_exp
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^x.1>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.8 )
                  case AMD_RoT_Certify
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                next
                  case SEV_PSP_Initialize
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                next
                  case TO_Enclave_Deploy_VM
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                next
                  case c_exp
                  solve( !KU( ~psp_sn ) @ #vk.10 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_4
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^inv((~go_sn*x.1)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j )
          case c_h
          solve( !KU( x^inv((~go_sn*x.1)) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', x^inv((~go_sn*x.1))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_5
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv(~go_sn)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kik', x^x.1>) ) @ #j )
          case c_h
          solve( !KU( x^(x.1*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_6
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv((~go_sn*x.2))) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j )
          case c_h
          solve( !KU( x^(x.1*inv((~go_sn*x.2))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv((~go_sn*x.2)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
next
  case case_4
  solve( splitEqs(0) )
    case split_case_1
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( k ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tek ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.5 )
            case AMD_RoT_Certify
            by contradiction /* non-normal terms */
          next
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.5 )
            case AMD_RoT_Certify
            by contradiction /* non-normal terms */
          next
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_2
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( ss^inv(~go_sn) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tek ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( ss^inv(~go_sn) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', ss^inv(~go_sn)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( ss^inv(~go_sn) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', ss^inv(~go_sn)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_3
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^x.1 ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tek ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^x.1 ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( senc(<'launch_secret', 
                                  h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~tek>,
                                 ~tek.1)
                       ) @ #vk.7 )
                  case c_senc
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( senc(<'launch_secret', 
                                  h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~tek>,
                                 ~tek.1)
                       ) @ #vk.7 )
                  case c_senc
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^x.1>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( senc(<'launch_secret', 
                                  h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~tek>,
                                 ~tek.1)
                       ) @ #vk.7 )
                  case c_senc
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^x.1 ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #vk.6 )
                  case c_h
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.9 )
                      case AMD_RoT_Certify
                      solve( !KU( ~go_sn ) @ #vk.10 )
                        case Adversary_Extract_SEV_Secret
                        solve( !KU( senc(<'launch_secret', 
                                          h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                         ~tek.1)
                               ) @ #vk.12 )
                          case c_senc
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case TO_Enclave_Deploy_VM
                      by contradiction /* from formulas */
                    next
                      case c_exp
                      by contradiction /* from formulas */
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #vk.6 )
                  case c_h
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.9 )
                      case SEV_PSP_Initialize
                      solve( !KU( ~go_sn ) @ #vk.10 )
                        case Adversary_Extract_SEV_Secret
                        solve( !KU( senc(<'launch_secret', 
                                          h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                         ~tek.1)
                               ) @ #vk.12 )
                          case c_senc
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case TO_Enclave_Deploy_VM
                      by contradiction /* from formulas */
                    next
                      case c_exp
                      by contradiction /* from formulas */
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^x.1>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #vk.6 )
                  case c_h
                  solve( !KU( ~psp_sn ) @ #vk.8 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_4
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^inv((~go_sn*x.1)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tek ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^inv((~go_sn*x.1)) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', x^inv((~go_sn*x.1))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^inv((~go_sn*x.1)) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', x^inv((~go_sn*x.1))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_5
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv(~go_sn)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tek ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^(x.1*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^(x.1*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_6
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv((~go_sn*x.2))) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tek ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^(x.1*inv((~go_sn*x.2))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv((~go_sn*x.2)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^(x.1*inv((~go_sn*x.2))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv((~go_sn*x.2)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
next
  case case_5
  solve( splitEqs(0) )
    case split_case_1
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( k ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tik ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.5 )
            case AMD_RoT_Certify
            by contradiction /* non-normal terms */
          next
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.5 )
            case AMD_RoT_Certify
            by contradiction /* non-normal terms */
          next
            case c_sign
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_2
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( ss^inv(~go_sn) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tik ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( ss^inv(~go_sn) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', ss^inv(~go_sn)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( ss^inv(~go_sn) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', ss^inv(~go_sn)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_3
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^x.1 ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tik ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^x.1 ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( senc(<'launch_secret', 
                                  h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~tik>,
                                 ~tek.1)
                       ) @ #vk.7 )
                  case c_senc
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( senc(<'launch_secret', 
                                  h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~tik>,
                                 ~tek.1)
                       ) @ #vk.7 )
                  case c_senc
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^x.1>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( senc(<'launch_secret', 
                                  h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~tik>,
                                 ~tek.1)
                       ) @ #vk.7 )
                  case c_senc
                  by contradiction /* cyclic */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^x.1 ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #vk.6 )
                  case c_h
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.9 )
                      case AMD_RoT_Certify
                      solve( !KU( ~go_sn ) @ #vk.10 )
                        case Adversary_Extract_SEV_Secret
                        solve( !KU( senc(<'launch_secret', 
                                          h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                         ~tek.1)
                               ) @ #vk.12 )
                          case c_senc
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case TO_Enclave_Deploy_VM
                      by contradiction /* from formulas */
                    next
                      case c_exp
                      by contradiction /* from formulas */
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #vk.6 )
                  case c_h
                  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.9 )
                      case SEV_PSP_Initialize
                      solve( !KU( ~go_sn ) @ #vk.10 )
                        case Adversary_Extract_SEV_Secret
                        solve( !KU( senc(<'launch_secret', 
                                          h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik.1>), ~go_sn>,
                                         ~tek.1)
                               ) @ #vk.12 )
                          case c_senc
                          by contradiction /* cyclic */
                        qed
                      qed
                    next
                      case TO_Enclave_Deploy_VM
                      by contradiction /* from formulas */
                    next
                      case c_exp
                      by contradiction /* from formulas */
                    qed
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x)>, ~amd_rot_ltk) ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^~go_sn>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x)>, ~amd_rot_ltk) ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^x.1>, ~amd_rot_ltk) ) @ #vk.5 )
              case AMD_RoT_Certify
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #vk.6 )
                  case c_h
                  solve( !KU( ~psp_sn ) @ #vk.8 )
                    case Adversary_Extract_SEV_Secret
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      by contradiction /* from formulas */
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case Compromise_SEV_PSP
                    by contradiction /* from formulas */
                  qed
                qed
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_4
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^inv((~go_sn*x.1)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tik ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^inv((~go_sn*x.1)) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', x^inv((~go_sn*x.1))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^inv((~go_sn*x.1)) ) @ #vk.4 )
            case c_exp
            solve( !KU( sign(<'sev_cert', x^inv((~go_sn*x.1))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_5
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv(~go_sn)) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tik ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^(x.1*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^(x.1*inv(~go_sn)) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv(~go_sn.1))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv(~go_sn))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case split_case_6
    solve( !SGX_Platform_Initialied( ~ppid ) ▶₀ #i )
      case SGX_QE_Initialize
      solve( Platform_PK_Verified( x^(x.1*inv((~go_sn*x.2))) ) ▶₁ #i )
        case TO_Enclave_Verify_Platform_Cert
        solve( !KU( ~tik ) @ #j )
          case Adversary_Extract_SEV_Secret
          solve( !KU( x^(x.1*inv((~go_sn*x.2))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv((~go_sn*x.2)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        next
          case TO_Enclave_Deploy_VM
          solve( !KU( x^(x.1*inv((~go_sn*x.2))) ) @ #vk.4 )
            case AMD_RoT_Certify_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case AMD_RoT_Certify_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case SEV_PSP_Initialize_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~psp_sn*x*inv((~go_sn*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_1
            solve( !KU( sign(<'sev_cert', 'g'^(~x*inv((~go_sn*x.1)))>, ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case TO_Enclave_Deploy_VM_case_2
            solve( !KU( sign(<'sev_cert', 'g'^(~go_sn*x*inv((~go_sn.1*x.1)))>,
                             ~amd_rot_ltk)
                   ) @ #vk.6 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          next
            case c_exp
            solve( !KU( sign(<'sev_cert', x^(x.1*inv((~go_sn*x.2)))>, ~amd_rot_ltk)
                   ) @ #vk.5 )
              case c_sign
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma lm_sev_guest_secret_secrecy_weak [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    (((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ k1 #j. Compromise_SEV_PSP( k1 ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ k1 #j. (Compromise_SEV_PSP( k1 ) @ #j) ⇒ ⊥)"
*/
simplify
solve( TO_Enclave_VM_Deployed( k, ~ppid, ~tek, ~tik, 'burrito_guest_vm'
       ) ▶₀ #i )
  case TO_Enclave_Deploy_VM
  solve( !KU( ~mnonce ) @ #vk.1 )
    case Adversary_Extract_SEV_Secret
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              solve( !KU( senc(<'launch_secret', 
                                h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~mnonce>,
                               ~tek.1)
                     ) @ #vk.13 )
                case c_senc
                by contradiction /* cyclic */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_AMD_RoT
    by contradiction /* from formulas */
  next
    case Compromise_Intel_RoT
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_SEV_PSP
    by contradiction /* from formulas */
  next
    case Compromise_SGX_QE
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Guest_VM_Request_Report
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.14 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.14 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Intel_RoT_Certify
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SEV_PSP_Initialize_Guest
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              solve( !KU( senc(<'transport_keys', ~tek.1, ~tik>, h(<'sev_kek', z>))
                     ) @ #vk.13 )
                case TO_Enclave_Deploy_VM
                solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                               h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                       ) @ #vk.14 )
                  case TO_Enclave_Deploy_VM
                  solve( splitEqs(2) )
                    case split_case_1
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~cik>,
                                       ~tek.1)
                             ) @ #vk.16 )
                        case TO_Enclave_Provision_VM
                        by contradiction /* from formulas */
                      next
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case split_case_2
                    solve( (∀ #j. (!KU( ~psp_sn.1 ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn.1 ) @ #j)) )
                      case case_1
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~cik>,
                                       ~tek.1)
                             ) @ #vk.16 )
                        case TO_Enclave_Provision_VM
                        by contradiction /* from formulas */
                      next
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  qed
                next
                  case c_h
                  by contradiction /* from formulas */
                qed
              next
                case c_senc
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Generate_Quote
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_1
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_2
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_1
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_2
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Provision_VM
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case fresh
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma lm_sev_guest_secret_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    (((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( TO_Enclave_VM_Deployed( k, ~ppid, ~tek, ~tik, 'burrito_guest_vm'
       ) ▶₀ #i )
  case TO_Enclave_Deploy_VM
  solve( !KU( ~mnonce ) @ #vk.1 )
    case Adversary_Extract_SEV_Secret
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              solve( !KU( senc(<'launch_secret', 
                                h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~mnonce>,
                               ~tek.1)
                     ) @ #vk.13 )
                case c_senc
                by contradiction /* cyclic */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_AMD_RoT
    by contradiction /* from formulas */
  next
    case Compromise_Intel_RoT
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_SEV_PSP
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_SGX_QE
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Guest_VM_Request_Report
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.14 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.14 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case Intel_RoT_Certify
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SEV_PSP_Initialize_Guest
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              solve( !KU( senc(<'transport_keys', ~tek.1, ~tik>, h(<'sev_kek', z>))
                     ) @ #vk.13 )
                case TO_Enclave_Deploy_VM
                solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                               h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                       ) @ #vk.14 )
                  case TO_Enclave_Deploy_VM
                  solve( splitEqs(2) )
                    case split_case_1
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~cik>,
                                       ~tek.1)
                             ) @ #vk.16 )
                        case TO_Enclave_Provision_VM
                        by contradiction /* from formulas */
                      next
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    next
                      case case_2
                      by contradiction /* from formulas */
                    qed
                  next
                    case split_case_2
                    solve( (∀ #j. (!KU( ~psp_sn.1 ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn.1 ) @ #j)) )
                      case case_1
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~cik>,
                                       ~tek.1)
                             ) @ #vk.16 )
                        case TO_Enclave_Provision_VM
                        by contradiction /* from formulas */
                      next
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    next
                      case case_2
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~cik>,
                                       ~tek.1)
                             ) @ #vk.16 )
                        case TO_Enclave_Provision_VM
                        by contradiction /* from formulas */
                      next
                        case c_senc
                        by contradiction /* cyclic */
                      qed
                    qed
                  qed
                next
                  case c_h
                  by contradiction /* from formulas */
                qed
              next
                case c_senc
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            qed
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Generate_Quote
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_1
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_2
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_1
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_2
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Provision_VM
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.13 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  next
    case fresh
    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
           ) @ #vk.2 )
      case c_h
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case TO_Enclave_Provision_VM
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( splitEqs(1) )
            case split_case_1
            solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_2
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_3
            solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_4
            solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_5
            solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case split_case_6
            solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma lm_sev_public_key_agreement [reuse, heuristic=C]:
  all-traces
  "∀ k1 k2 t s #i #j.
    ((TO_Enclave_Guest_Secrets( k1, t, s ) @ #i) ∧
     (SEV_PSP_Secrets( k2, t, s ) @ #j)) ⇒
    (((k1 = k2) ∨ (∃ #j.1. Compromise_AMD_RoT( ) @ #j.1)) ∨
     (∃ #j.1. Compromise_SEV_PSP( k1 ) @ #j.1))"
/*
guarded formula characterizing all counter-examples:
"∃ k1 k2 t s #i #j.
  (TO_Enclave_Guest_Secrets( k1, t, s ) @ #i) ∧
  (SEV_PSP_Secrets( k2, t, s ) @ #j)
 ∧
  (¬(k1 = k2)) ∧
  (∀ #j.1. (Compromise_AMD_RoT( ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_SEV_PSP( k1 ) @ #j.1) ⇒ ⊥)"
*/
simplify
solve( TO_Enclave_VM_Deployed( k1, ~ppid, ~tek, ~tik, $vm_dig ) ▶₀ #i )
  case TO_Enclave_Deploy_VM
  solve( !KU( ~mnonce ) @ #vk.1 )
    case Adversary_Extract_SEV_Secret
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.4 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.5 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                  case case_1
                  solve( !KU( senc(<'launch_secret', 
                                    h(<'launch_measurement', ~mnonce.1, $vm_dig.1, ~tik.1>), ~mnonce>,
                                   ~tek.1)
                         ) @ #vk.16 )
                    case c_senc
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.5 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                  case case_1
                  solve( !KU( senc(<'launch_secret', 
                                    h(<'launch_measurement', ~mnonce.1, $vm_dig.1, ~tik.1>), ~mnonce>,
                                   ~tek.2)
                         ) @ #vk.18 )
                    case c_senc
                    by contradiction /* cyclic */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.15 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.17 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.17 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_AMD_RoT
    by contradiction /* from formulas */
  next
    case Compromise_Intel_RoT
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_SEV_PSP
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case Compromise_SGX_QE
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case Guest_VM_Request_Report
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case Intel_RoT_Certify
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case SEV_PSP_Initialize_Guest
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.4 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.5 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                  case case_1
                  solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>))
                         ) @ #vk.16 )
                    case TO_Enclave_Deploy_VM
                    solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                   h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                           ) @ #vk.17 )
                      case TO_Enclave_Deploy_VM
                      solve( splitEqs(3) )
                        case split_case_1
                        by contradiction /* from formulas */
                      next
                        case split_case_2
                        solve( (∀ #j. (!KU( ~psp_sn.1 ) @ #j) ⇒ ⊥)  ∥
                               (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn.1 ) @ #j)) )
                          case case_1
                          solve( !KU( 'g'^~psp_sn ) @ #vk.16 )
                            case AMD_RoT_Certify
                            solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                              case case_1
                              solve( !KU( 'g'^(~go_sn*~psp_sn*inv(~psp_sn.1)) ) @ #vk.17 )
                                case AMD_RoT_Certify
                                by contradiction /* from formulas */
                              next
                                case TO_Enclave_Deploy_VM
                                by contradiction /* from formulas */
                              next
                                case c_exp
                                by contradiction /* from formulas */
                              qed
                            next
                              case case_2
                              by contradiction /* from formulas */
                            qed
                          next
                            case SEV_PSP_Initialize
                            solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                              case case_1
                              solve( !KU( 'g'^(~go_sn*~psp_sn*inv(~psp_sn.1)) ) @ #vk.17 )
                                case SEV_PSP_Initialize
                                by contradiction /* from formulas */
                              next
                                case TO_Enclave_Deploy_VM
                                by contradiction /* from formulas */
                              next
                                case c_exp
                                by contradiction /* from formulas */
                              qed
                            next
                              case case_2
                              by contradiction /* from formulas */
                            qed
                          next
                            case c_exp
                            solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                              case case_1
                              by contradiction /* from formulas */
                            next
                              case case_2
                              by contradiction /* from formulas */
                            qed
                          qed
                        next
                          case case_2
                          solve( !KU( 'g'^~psp_sn ) @ #vk.16 )
                            case AMD_RoT_Certify
                            solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                              case case_1
                              solve( !KU( 'g'^(~go_sn*~psp_sn*inv(~psp_sn.1)) ) @ #vk.17 )
                                case AMD_RoT_Certify
                                solve( !PSP_Ltk( ~cpu_id.1, ~psp_sn.2 ) ▶₀ #j.1 )
                                  case SEV_PSP_Initialize
                                  solve( !PSP_Pk( ~cpu_id.1, 'g'^~psp_sn.1 ) ▶₁ #j.1 )
                                    case SEV_PSP_Initialize
                                    solve( !KU( ~go_sn ) @ #vk.19 )
                                      case Adversary_Extract_SEV_Secret
                                      solve( !KU( ~psp_sn.1 ) @ #vk.21 )
                                        case Adversary_Extract_SEV_Secret
                                        solve( !KU( senc(<'launch_secret', 
                                                          h(<'launch_measurement', ~mnonce.1, $vm_dig.1, 
                                                             ~tik.1>), 
                                                          ~go_sn>,
                                                         ~tek.1)
                                               ) @ #vk.23 )
                                          case c_senc
                                          by contradiction /* cyclic */
                                        qed
                                      next
                                        case Compromise_SEV_PSP
                                        solve( !KU( senc(<'launch_secret', 
                                                          h(<'launch_measurement', ~mnonce.1, $vm_dig.1, 
                                                             ~tik.1>), 
                                                          ~go_sn>,
                                                         ~tek.1)
                                               ) @ #vk.23 )
                                          case c_senc
                                          by contradiction /* cyclic */
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              next
                                case TO_Enclave_Deploy_VM
                                by contradiction /* from formulas */
                              next
                                case c_exp
                                by contradiction /* from formulas */
                              qed
                            next
                              case case_2
                              by contradiction /* from formulas */
                            qed
                          next
                            case SEV_PSP_Initialize
                            solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                              case case_1
                              solve( !KU( 'g'^(~go_sn*~psp_sn*inv(~psp_sn.1)) ) @ #vk.17 )
                                case SEV_PSP_Initialize
                                solve( !PSP_Ltk( ~cpu_id.1, ~psp_sn.2 ) ▶₀ #j.1 )
                                  case SEV_PSP_Initialize
                                  solve( !PSP_Pk( ~cpu_id.1, 'g'^~psp_sn.1 ) ▶₁ #j.1 )
                                    case SEV_PSP_Initialize
                                    solve( !KU( ~go_sn ) @ #vk.19 )
                                      case Adversary_Extract_SEV_Secret
                                      solve( !KU( ~psp_sn.1 ) @ #vk.21 )
                                        case Adversary_Extract_SEV_Secret
                                        solve( !KU( senc(<'launch_secret', 
                                                          h(<'launch_measurement', ~mnonce.1, $vm_dig.1, 
                                                             ~tik.1>), 
                                                          ~go_sn>,
                                                         ~tek.1)
                                               ) @ #vk.23 )
                                          case c_senc
                                          by contradiction /* cyclic */
                                        qed
                                      next
                                        case Compromise_SEV_PSP
                                        solve( !KU( senc(<'launch_secret', 
                                                          h(<'launch_measurement', ~mnonce.1, $vm_dig.1, 
                                                             ~tik.1>), 
                                                          ~go_sn>,
                                                         ~tek.1)
                                               ) @ #vk.23 )
                                          case c_senc
                                          by contradiction /* cyclic */
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              next
                                case TO_Enclave_Deploy_VM
                                by contradiction /* from formulas */
                              next
                                case c_exp
                                by contradiction /* from formulas */
                              qed
                            next
                              case case_2
                              by contradiction /* from formulas */
                            qed
                          next
                            case c_exp
                            solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                              case case_1
                              by contradiction /* from formulas */
                            next
                              case case_2
                              by contradiction /* from formulas */
                            qed
                          qed
                        qed
                      qed
                    next
                      case c_h
                      by contradiction /* from formulas */
                    qed
                  next
                    case c_senc
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.5 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                  case case_1
                  solve( !KU( senc(<'transport_keys', ~tek.1, ~tik>, h(<'sev_kek', z>))
                         ) @ #vk.18 )
                    case TO_Enclave_Deploy_VM
                    by contradiction /* from formulas */
                  next
                    case c_senc
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                qed
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    by contradiction /* from formulas */
                  next
                    case case_2
                    by contradiction /* from formulas */
                  qed
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    next
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.15 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.17 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.17 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Generate_Quote
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_1
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_2
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_1
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_2
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~psp_sn*~go_sn.1) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~psp_sn*~go_sn.1)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn.1*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn.1*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Provision_VM
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.16 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  next
    case fresh
    solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>) ) @ #vk.2 )
      case c_h
      solve( !KU( senc(<'launch_secret', measure, ~cik>, ~tek.1) ) @ #vk.5 )
        case TO_Enclave_Provision_VM
        solve( !KU( h(<
                       <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
                       >, 
                       ~tik>)
               ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek, ~tik, $vm_dig.1,
                                               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        qed
      next
        case c_senc
        solve( !KU( h(<<'launch_secret', measure, ~cik>, ~tik>) ) @ #vk.7 )
          case TO_Enclave_Provision_VM
          by solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik,
                                               $vm_dig.1, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                    ) ▶₁ #j )
        next
          case c_h
          solve( SEV_PSP_Guest_Initialized( ~cpu_id, k2, ~tek.1, ~tik, $vm_dig.1,
                                            measure
                 ) ▶₁ #j )
            case SEV_PSP_Initialize_Guest
            solve( !KU( sign(<'sev_cert', k1>, ~amd_rot_ltk) ) @ #vk.14 )
              case AMD_RoT_Certify
              solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              next
                case case_3
                by contradiction /* from formulas */
              qed
            next
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k1^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k1^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_2
                solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( z^inv(~go_sn) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_3
                solve( ((∀ #j. (!KU( x^(~go_sn*x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(~go_sn*x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^x.1 ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_4
                solve( ((∀ #j. (!KU( x^inv(x.1) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^inv(x.1)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^inv((~go_sn*x.1)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_5
                solve( ((∀ #j. (!KU( x^x.1 ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^x.1>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv(~go_sn)) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              next
                case split_case_6
                solve( ((∀ #j. (!KU( x^(x.1*inv(x.2)) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', x^(x.1*inv(x.2))>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( x^(x.1*inv((~go_sn*x.2))) ) @ #j)) )
                  case case_1
                  by contradiction /* from formulas */
                next
                  case case_2
                  by contradiction /* from formulas */
                next
                  case case_3
                  by contradiction /* from formulas */
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma lm_sgx_intel_rot_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ltk #i.
    (Intel_RoT_Key( ltk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk #i.
  (Intel_RoT_Key( ltk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧ (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !KU( ~intel_rot_ltk ) @ #j )
  case Adversary_Extract_SEV_Secret
  solve( !KU( senc(<'launch_secret', 
                    h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~intel_rot_ltk>,
                   ~tek)
         ) @ #vk.1 )
    case c_senc
    by contradiction /* cyclic */
  qed
next
  case Compromise_Intel_RoT
  by contradiction /* from formulas */
qed

lemma lm_sgx_qe_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ppid ltk #i.
    (SGX_QE_Ltk( ppid, ltk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid ltk #i.
  (SGX_QE_Ltk( ppid, ltk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧ (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !KU( ~qe_ltk ) @ #j )
  case Adversary_Extract_SEV_Secret
  solve( !KU( senc(<'launch_secret', 
                    h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~qe_ltk>,
                   ~tek)
         ) @ #vk.1 )
    case c_senc
    by contradiction /* cyclic */
  qed
next
  case Compromise_SGX_QE
  by contradiction /* from formulas */
qed

lemma lm_sgx_rp_qe_ltk_authenticity [reuse, heuristic=C]:
  all-traces
  "∀ ltk ppid #i.
    (RP_QE_Ltk( ltk, ppid ) @ #i) ⇒
    ((∃ #j. SGX_QE_Ltk( ppid, ltk ) @ #j) ∨
     (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk ppid #i.
  (RP_QE_Ltk( ltk, ppid ) @ #i)
 ∧
  (∀ #j. (SGX_QE_Ltk( ppid, ltk ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
  case Intel_RoT_Initialize
  solve( !KU( ~ppid ) @ #vk.7 )
    case Adversary_Extract_SEV_Secret
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_AMD_RoT
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~ppid), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_Intel_RoT
    by contradiction /* from formulas */
  next
    case Compromise_SEV_PSP
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_SGX_QE
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Guest_VM_Request_Report
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Intel_RoT_Certify
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SEV_PSP_Initialize_Guest
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Generate_Quote
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_1
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_2
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          by contradiction /* from formulas */
        next
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_1
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_2
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Provision_VM
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case fresh
    solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  qed
qed

lemma lm_sgx_rp_qe_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ltk ppid #i.
    (RP_QE_Ltk( ltk, ppid ) @ #i) ⇒
    (((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
     (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk ppid #i.
  (RP_QE_Ltk( ltk, ppid ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
  case case_1
  solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
    case Intel_RoT_Initialize
    solve( !KU( ~ppid ) @ #vk.7 )
      case Adversary_Extract_SEV_Secret
      solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case SGX_QE_Generate_Quote_case_1
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case SGX_QE_Generate_Quote_case_2
        solve( !KU( pk(~qe_ltk) ) @ #vk.16 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case c_sign
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case Intel_RoT_Certify
      solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case SGX_QE_Generate_Quote_case_1
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case SGX_QE_Generate_Quote_case_2
        solve( !KU( pk(~qe_ltk) ) @ #vk.16 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case c_sign
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case SGX_QE_Generate_Quote
      solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case SGX_QE_Generate_Quote_case_1
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case SGX_QE_Generate_Quote_case_2
        solve( !KU( pk(~qe_ltk) ) @ #vk.16 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case c_sign
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case SGX_QE_Initialize_case_1
      solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case SGX_QE_Generate_Quote_case_1
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case SGX_QE_Generate_Quote_case_2
        solve( !KU( pk(~qe_ltk) ) @ #vk.16 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case c_sign
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    next
      case SGX_QE_Initialize_case_2
      solve( !KU( sign(<'sgx_quote', $measurement, ~ppid, report_data>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case SGX_QE_Generate_Quote_case_1
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case SGX_QE_Generate_Quote_case_2
        solve( !KU( pk(~qe_ltk) ) @ #vk.16 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      next
        case c_sign
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case SGX_QE_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        next
          case c_pk
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            solve( !KU( ~qe_ltk ) @ #j.1 )
              case Adversary_Extract_SEV_Secret
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                by contradiction /* from formulas */
              next
                case case_2
                by contradiction /* from formulas */
              qed
            next
              case Compromise_SGX_QE
              by contradiction /* from formulas */
            qed
          qed
        qed
      qed
    qed
  qed
next
  case case_2
  by contradiction /* from formulas */
qed

lemma lm_sgx_quote_authenticity_weak [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    (((∃ v d k #j.
        (rd = h(<'report_data', k, d, v>)) ∧
        (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
      (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
     (∃ ppid_1 #j. Compromise_SGX_QE( ppid_1 ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ ppid_1 #j. (Compromise_SGX_QE( ppid_1 ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
  case Intel_RoT_Initialize
  solve( !KU( ~ppid ) @ #vk.7 )
    case Adversary_Extract_SEV_Secret
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_AMD_RoT
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~ppid), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~ppid ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_Intel_RoT
    by contradiction /* from formulas */
  next
    case Compromise_SEV_PSP
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_SGX_QE
    by contradiction /* from formulas */
  next
    case Guest_VM_Request_Report
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Intel_RoT_Certify
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SEV_PSP_Initialize_Guest
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Generate_Quote
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_1
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_2
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_1
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_2
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Provision_VM
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case fresh
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  qed
qed

lemma lm_sgx_quote_authenticity [reuse, heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    (((∃ v d k #j.
        (rd = h(<'report_data', k, d, v>)) ∧
        (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
      (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
  case Intel_RoT_Initialize
  solve( !KU( ~ppid ) @ #vk.7 )
    case Adversary_Extract_SEV_Secret
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_AMD_RoT
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~ppid), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~ppid ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_Intel_RoT
    by contradiction /* from formulas */
  next
    case Compromise_SEV_PSP
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Compromise_SGX_QE
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Guest_VM_Request_Report
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case Intel_RoT_Certify
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SEV_PSP_Initialize_Guest
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Generate_Quote
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_1
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case SGX_QE_Initialize_case_2
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote_case_1
      by contradiction /* from formulas */
    next
      case SGX_QE_Generate_Quote_case_2
      by contradiction /* from formulas */
    next
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        next
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_1
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Deploy_VM_case_2
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case TO_Enclave_Provision_VM
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~amd_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  next
    case fresh
    solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                      rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case c_sign
      solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
        case AMD_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case Intel_RoT_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~intel_rot_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case SGX_QE_Initialize
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      next
        case c_pk
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.15 )
          case c_sign
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            by contradiction /* from formulas */
          next
            case case_2
            by contradiction /* from formulas */
          next
            case case_3
            by contradiction /* from formulas */
          qed
        qed
      qed
    qed
  qed
qed

lemma lm_burrito_quote_integrity_weak [heuristic=o "oracle.py",
                                       hide_lemma=lm_sev_enclave_secrets_secrecy,
                                       hide_lemma=lm_sev_psp_ltk_secrecy,
                                       hide_lemma=lm_sev_amd_rot_ltk_secrecy,
                                       hide_lemma=lm_sgx_intel_rot_ltk_secrecy,
                                       hide_lemma=lm_sgx_qe_ltk_secrecy,
                                       hide_lemma=lm_sgx_rp_qe_ltk_authenticity,
                                       hide_lemma=lm_sgx_rp_qe_ltk_secrecy]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ ppid1 #j. Compromise_SGX_QE( ppid1 ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ k1 #j. Compromise_SEV_PSP( k1 ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ ppid1 #j. (Compromise_SGX_QE( ppid1 ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ k1 #j. (Compromise_SEV_PSP( k1 ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( TO_Enclave_VM_Provisioned( k, ~ppid, <m, 'burrito_guest_vm'>, ~cik
         ) ▶₀ #j )
    case TO_Enclave_Provision_VM
    solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
           (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
           (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
      case case_1
      solve( !KU( h(<'report_request', d, ~cik>) ) @ #vk.18 )
        case Guest_VM_Request_Report
        solve( !KU( senc(<'launch_secret', 
                          h(<'launch_measurement', ~mnonce.1, 'burrito_guest_vm', ~tik.1>), ~cik>,
                         ~tek.1)
               ) @ #vk.30 )
          case TO_Enclave_Provision_VM
          solve( !KU( h(<
                         <'launch_secret', 
                          h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>), ~cik>, 
                         ~tik>)
                 ) @ #vk.32 )
            case TO_Enclave_Provision_VM
            solve( (k = 'g'^~psp_sn)  ∥ (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case c_h
            by contradiction /* from formulas */
          qed
        next
          case c_senc
          by contradiction /* from formulas */
        qed
      next
        case c_h
        by contradiction /* from formulas */
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      by contradiction /* from formulas */
    qed
  qed
next
  case case_2
  by contradiction /* from formulas */
next
  case case_3
  by contradiction /* from formulas */
qed

lemma lm_burrito_quote_integrity_strong [heuristic=o "oracle.py",
                                         hide_lemma=lm_sev_enclave_secrets_secrecy,
                                         hide_lemma=lm_sev_psp_ltk_secrecy,
                                         hide_lemma=lm_sev_amd_rot_ltk_secrecy,
                                         hide_lemma=lm_sgx_intel_rot_ltk_secrecy,
                                         hide_lemma=lm_sgx_qe_ltk_secrecy,
                                         hide_lemma=lm_sgx_rp_qe_ltk_authenticity,
                                         hide_lemma=lm_sgx_rp_qe_ltk_secrecy]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( TO_Enclave_VM_Provisioned( k, ~ppid, <m, 'burrito_guest_vm'>, ~cik
         ) ▶₀ #j )
    case TO_Enclave_Provision_VM
    solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
           (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
           (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
      case case_1
      solve( !KU( h(<'report_request', d, ~cik>) ) @ #vk.18 )
        case Guest_VM_Request_Report
        solve( !KU( senc(<'launch_secret', 
                          h(<'launch_measurement', ~mnonce.1, 'burrito_guest_vm', ~tik.1>), ~cik>,
                         ~tek.1)
               ) @ #vk.30 )
          case TO_Enclave_Provision_VM
          solve( !KU( h(<
                         <'launch_secret', 
                          h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>), ~cik>, 
                         ~tik>)
                 ) @ #vk.32 )
            case TO_Enclave_Provision_VM
            solve( (k = 'g'^~psp_sn)  ∥ (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              by contradiction /* from formulas */
            next
              case case_2
              by contradiction /* from formulas */
            next
              case case_3
              by contradiction /* from formulas */
            qed
          next
            case c_h
            by contradiction /* from formulas */
          qed
        next
          case c_senc
          by contradiction /* from formulas */
        qed
      next
        case c_h
        by contradiction /* from formulas */
      qed
    next
      case case_2
      by contradiction /* from formulas */
    next
      case case_3
      by contradiction /* from formulas */
    qed
  qed
next
  case case_2
  by contradiction /* from formulas */
next
  case case_3
  by contradiction /* from formulas */
qed

lemma ex_can_generate_burrito_quote:
  exists-trace
  "∃ ppid k ts m #i #j.
    (((((RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', 
                           ppid, 
                           h(<'report_data', k, <m, 'burrito_guest_vm'>, 'burrito_report', ts>)>
         ) @ #i) ∧
        (Guest_VM_Request_Report( k, ts ) @ #j)) ∧
       (¬(∃ #j.1. Compromise_Intel_RoT( ) @ #j.1))) ∧
      (¬(∃ #j.1. Compromise_SGX_QE( ppid ) @ #j.1))) ∧
     (¬(∃ #j.1. Compromise_AMD_RoT( ) @ #j.1))) ∧
    (¬(∃ #j.1. Compromise_SEV_PSP( k ) @ #j.1))"
/*
guarded formula characterizing all satisfying traces:
"∃ ppid k ts m #i #j.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, 'burrito_report', ts>)>
   ) @ #i) ∧
  (Guest_VM_Request_Report( k, ts ) @ #j)
 ∧
  (∀ #j.1. (Compromise_Intel_RoT( ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_SGX_QE( ppid ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_AMD_RoT( ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_SEV_PSP( k ) @ #j.1) ⇒ ⊥)"
*/
by sorry

lemma ex_can_verify_quote_created_by_adversary:
  exists-trace
  "∃ ppid #i.
    RP_Verify_Quote( <'sgx_quote', 'arbitrary_sgx_measurement', ppid, 
                      'arbitrary_data'>
    ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ ppid #i.
  (RP_Verify_Quote( <'sgx_quote', 'arbitrary_sgx_measurement', ppid, 
                     'arbitrary_data'>
   ) @ #i)"
*/
by sorry

lemma ex_adversary_can_launch_sev_guest:
  exists-trace
  "((∃ #i. SEV_PSP_Launch_Guest( ) @ #i) ∧
    (¬(∃ #j. Compromise_AMD_RoT( ) @ #j))) ∧
   (¬(∃ c #j. TO_Enclave_Verify_Platform_Cert( c ) @ #j))"
/*
guarded formula characterizing all satisfying traces:
"(∃ #i. (SEV_PSP_Launch_Guest( ) @ #i)) ∧
 (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
 (∀ c #j. (TO_Enclave_Verify_Platform_Cert( c ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma ex_adversary_can_launch_sev_guest_and_extract_secret:
  exists-trace
  "(∃ s #i. Adversary_Extract_SEV_Secret( 'arbitrary_vmc', s ) @ #i) ∧
   (¬(∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all satisfying traces:
"(∃ s #i. (Adversary_Extract_SEV_Secret( 'arbitrary_vmc', s ) @ #i)) ∧
 (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma ex_can_launch_sev_guest_without_adversary:
  exists-trace
  "((∃ #i. SEV_PSP_Launch_Guest( ) @ #i) ∧
    (¬(∃ #j. Compromise_AMD_RoT( ) @ #j))) ∧
   (¬(∃ k #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all satisfying traces:
"(∃ #i. (SEV_PSP_Launch_Guest( ) @ #i)) ∧
 (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
 (∀ k #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sgx_quote_authenticity_1 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                       ppid, rd>
     ) @ #i) ⇒
    (((∃ v d k #j.
        (rd = h(<'report_data', k, d, v>)) ∧
        (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
      (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                     ppid, rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sgx_quote_authenticity_2 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    ((∃ #j. Compromise_Intel_RoT( ) @ #j) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sgx_quote_authenticity_3 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    ((∃ v d k #j.
       (rd = h(<'report_data', k, d, v>)) ∧
       (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sgx_quote_authenticity_4 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    ((∃ v d k #j.
       (rd = h(<'report_data', k, d, v>)) ∧
       (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
     (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sev_guest_secret_secrecy_1 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'fake_burrito_guest_vm' ) @ #i) ⇒
    (((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'fake_burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sev_guest_secret_secrecy_2 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    ((∃ #j. Compromise_AMD_RoT( ) @ #j) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sev_guest_secret_secrecy_3 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    ((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧ (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_sev_guest_secret_secrecy_4 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    ((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧ (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_burrito_quote_integrity_1 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                       ppid, h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                     ppid, h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_burrito_quote_integrity_2 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'fake_burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'fake_burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_burrito_quote_integrity_3 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ #j. Compromise_Intel_RoT( ) @ #j) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_burrito_quote_integrity_4 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_burrito_quote_integrity_5 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_burrito_quote_integrity_6 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
      (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma should_fail_lm_burrito_quote_integrity_7 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
      (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
     (∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

/* All well-formedness checks were successful. */

end