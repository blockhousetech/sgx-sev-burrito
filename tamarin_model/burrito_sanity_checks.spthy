theory burrito begin

// Function signature and definition of the equational theory E

builtins: diffie-hellman
functions: fst/1, h/1, pair/2, pk/1, sdec/2, senc/2, sign/2, snd/1,
           true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true



rule (modulo E) Intel_RoT_Initialize[color=#ffbf00]:
   [ Fr( ~intel_rot_ltk ) ]
  --[ Intel_RoT_Initialize( ), Intel_RoT_Key( ~intel_rot_ltk ) ]->
   [
   Out( pk(~intel_rot_ltk) ), !Intel_RoT_Pk( pk(~intel_rot_ltk) ),
   !Intel_RoT_Ltk( ~intel_rot_ltk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Intel_RoT_Certify[color=#ffbf00]:
   [
   QE_CSR( ~ppid, platform_data, qek_pk ), !Intel_RoT_Ltk( ~intel_rot_ltk )
   ]
  --[
  Intel_RoT_Certify( <<'sgx_cert', qek_pk, ~ppid>, 
                      sign(<'sgx_cert', qek_pk, ~ppid>, ~intel_rot_ltk)>
  )
  ]->
   [
   Out( <<'sgx_cert', qek_pk, ~ppid>, 
         sign(<'sgx_cert', qek_pk, ~ppid>, ~intel_rot_ltk)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SGX_QE_Initialize[color=#e83f6f]:
   [ Fr( ~ppid ), Fr( ~qe_ltk ) ]
  --[ SGX_QE_Initialize( ), SGX_QE_Ltk( ~ppid, ~qe_ltk ) ]->
   [
   Out( ~ppid ), Out( ~ppid ), Out( pk(~qe_ltk) ),
   QE_CSR( ~ppid, ~ppid, pk(~qe_ltk) ), !QE_Ltk( ~ppid, ~ppid, ~qe_ltk ),
   !SGX_Platform_Initialied( ~ppid )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SGX_QE_Generate_Quote[color=#e83f6f]:
   [
   !QE_Ltk( ~ppid, platform_data, ~qe_ltk ),
   Quote_Request( ~ppid, $measurement, report_data )
   ]
  --[
  SGX_QE_Generate_Quote( <
                          <'sgx_quote', $measurement, platform_data, report_data>, 
                          sign(<'sgx_quote', $measurement, platform_data, report_data>, ~qe_ltk)>
  )
  ]->
   [
   Out( <<'sgx_quote', $measurement, platform_data, report_data>, 
         sign(<'sgx_quote', $measurement, platform_data, report_data>, ~qe_ltk)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) AMD_RoT_Initialize[color=#32936f]:
   [ Fr( ~amd_rot_ltk ) ]
  --[ AMD_RoT_Initialize( ), AMD_RoT_Key( ~amd_rot_ltk ) ]->
   [
   Out( pk(~amd_rot_ltk) ), !AMD_RoT_Pk( pk(~amd_rot_ltk) ),
   !AMD_RoT_Ltk( ~amd_rot_ltk )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) AMD_RoT_Certify[color=#32936f]:
   [ PSP_CSR( ~cpu_id, psp_sn_pk ), !AMD_RoT_Ltk( ~amd_rot_ltk ) ]
  --[
  AMD_RoT_Certify( <<'sev_cert', psp_sn_pk>, 
                    sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)>
  )
  ]->
   [
   Out( <<'sev_cert', psp_sn_pk>, 
         sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SEV_PSP_Initialize[color=#2a848a]:
   [ Fr( ~cpu_id ), Fr( ~psp_sn ) ]
  --[ SEV_PSP_Initialize( ), SEV_PSP_Ltk( ~cpu_id, ~psp_sn, 'g'^~psp_sn )
  ]->
   [
   Out( 'g'^~psp_sn ), PSP_CSR( ~cpu_id, 'g'^~psp_sn ),
   !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, 'g'^~psp_sn )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) SEV_PSP_Initialize_Guest[color=#2a848a]:
   [
   In( <go_sn_pk, 
        senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', go_sn_pk^~psp_sn>)), 
        h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', go_sn_pk^~psp_sn>)>), 
        $vm_dig>
   ),
   !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, psp_sn_pk ),
   Fr( ~mnonce )
   ]
  --[ SEV_PSP_Initialize_Guest( ) ]->
   [
   SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik, $vm_dig,
                              h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
   ),
   Out( <~mnonce, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)> )
   ]

  /*
  rule (modulo AC) SEV_PSP_Initialize_Guest[color=#2a848a]:
     [
     In( <go_sn_pk, senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>)), 
          h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', z>)>), $vm_dig>
     ),
     !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, psp_sn_pk ),
     Fr( ~mnonce )
     ]
    --[ SEV_PSP_Initialize_Guest( ) ]->
     [
     SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik, $vm_dig,
                                h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
     ),
     Out( <~mnonce, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)> )
     ]
    variants (modulo AC)
    1. ~psp_sn
             = ~psp_sn.16
       go_sn_pk
             = go_sn_pk.19
       z     = go_sn_pk.19^~psp_sn.16
    
    2. ~psp_sn
             = ~psp_sn.20
       go_sn_pk
             = z.27^inv(~psp_sn.20)
       z     = z.27
    
    3. ~psp_sn
             = ~psp_sn.44
       go_sn_pk
             = x.82^x.83
       z     = x.82^(~psp_sn.44*x.83)
    
    4. ~psp_sn
             = ~psp_sn.47
       go_sn_pk
             = x.88^inv((~psp_sn.47*x.89))
       z     = x.88^inv(x.89)
    
    5. ~psp_sn
             = ~psp_sn.47
       go_sn_pk
             = x.88^(x.89*inv(~psp_sn.47))
       z     = x.88^x.89
    
    6. ~psp_sn
             = ~psp_sn.48
       go_sn_pk
             = x.89^(x.90*inv((~psp_sn.48*x.91)))
       z     = x.89^(x.90*inv(x.91))
  */

rule (modulo E) SEV_PSP_Launch_Guest[color=#2a848a]:
   [
   In( <senc(<'launch_secret', measure, ~guest_secret>, ~tek), 
        h(<<'launch_secret', measure, ~guest_secret>, ~tik>)>
   ),
   SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik, $vm_dig,
                              measure
   )
   ]
  --[
  SEV_PSP_Launch_Guest( ),
  SEV_PSP_Secrets( psp_sn_pk, ~tik, ~guest_secret )
  ]->
   [ !SEV_PSP_Guest_Running( ~cpu_id, psp_sn_pk, $vm_dig, ~guest_secret ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TO_Enclave_Verify_Platform_Cert[color=#2274a5]:
   [
   !AMD_RoT_Pk( pk(~amd_rot_ltk) ),
   In( <<'sev_cert', psp_sn_pk>, sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)
       >
   )
   ]
  --[
  TO_Enclave_Verify_Platform_Cert( <<'sev_cert', psp_sn_pk>, 
                                    sign(<'sev_cert', psp_sn_pk>, ~amd_rot_ltk)>
  )
  ]->
   [ Platform_PK_Verified( psp_sn_pk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) TO_Enclave_Deploy_VM[color=#2274a5]:
   [
   !SGX_Platform_Initialied( ~ppid ), Platform_PK_Verified( psp_sn_pk ),
   In( $vm_dig ), Fr( ~go_sn ), Fr( ~tek ), Fr( ~tik )
   ]
  --[
  TO_Enclave_Deploy_VM( ),
  TO_Enclave_Secrets( psp_sn_pk, psp_sn_pk^~go_sn,
                      h(<'sev_kek', psp_sn_pk^~go_sn>), h(<'sev_kik', psp_sn_pk^~go_sn>), ~tek,
                      ~tik
  )
  ]->
   [
   Out( <'g'^~go_sn, 
         senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', psp_sn_pk^~go_sn>)), 
         h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', psp_sn_pk^~go_sn>)>), 
         $vm_dig>
   ),
   TO_Enclave_VM_Deployed( psp_sn_pk, ~ppid, ~tek, ~tik, $vm_dig )
   ]

  /*
  rule (modulo AC) TO_Enclave_Deploy_VM[color=#2274a5]:
     [
     !SGX_Platform_Initialied( ~ppid ), Platform_PK_Verified( psp_sn_pk ),
     In( $vm_dig ), Fr( ~go_sn ), Fr( ~tek ), Fr( ~tik )
     ]
    --[
    TO_Enclave_Deploy_VM( ),
    TO_Enclave_Secrets( psp_sn_pk, z, h(<'sev_kek', z>), h(<'sev_kik', z>),
                        ~tek, ~tik
    )
    ]->
     [
     Out( <'g'^~go_sn, 
           senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>)), 
           h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', z>)>), $vm_dig>
     ),
     TO_Enclave_VM_Deployed( psp_sn_pk, ~ppid, ~tek, ~tik, $vm_dig )
     ]
    variants (modulo AC)
    1. ~go_sn
             = ~go_sn.16
       psp_sn_pk
             = psp_sn_pk.20
       z     = psp_sn_pk.20^~go_sn.16
    
    2. ~go_sn
             = ~go_sn.20
       psp_sn_pk
             = z.28^inv(~go_sn.20)
       z     = z.28
    
    3. ~go_sn
             = ~go_sn.85
       psp_sn_pk
             = x.166^x.167
       z     = x.166^(~go_sn.85*x.167)
    
    4. ~go_sn
             = ~go_sn.89
       psp_sn_pk
             = x.174^inv((~go_sn.89*x.175))
       z     = x.174^inv(x.175)
    
    5. ~go_sn
             = ~go_sn.89
       psp_sn_pk
             = x.174^(x.175*inv(~go_sn.89))
       z     = x.174^x.175
    
    6. ~go_sn
             = ~go_sn.90
       psp_sn_pk
             = x.175^(x.176*inv((~go_sn.90*x.177)))
       z     = x.175^(x.176*inv(x.177))
  */

rule (modulo E) TO_Enclave_Provision_VM[color=#2274a5]:
   [
   TO_Enclave_VM_Deployed( psp_sn_pk, ~ppid, ~tek, ~tik, $vm_dig ),
   In( <~mnonce, h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)> ),
   Fr( ~cik )
   ]
  --[
  TO_Enclave_Provision_VM( psp_sn_pk, ~cik, $vm_dig ),
  TO_Enclave_Guest_Secrets( psp_sn_pk, ~tik, ~cik )
  ]->
   [
   Out( <
         senc(<'launch_secret', 
               h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik>,
              ~tek), 
         h(<
            <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~cik
            >, 
            ~tik>)
        >
   ),
   TO_Enclave_VM_Provisioned( psp_sn_pk, ~ppid, <~mnonce, $vm_dig>, ~cik )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) TO_Enclave_Generate_Report_For_VM[color=#2274a5]:
   [
   TO_Enclave_VM_Provisioned( psp_sn_pk, ~ppid, msr, ~cik ),
   In( <vm_data, h(<'report_request', vm_data, ~cik>)> )
   ]
  --[ TO_Enclave_Generate_Report_For_VM( ~ppid, psp_sn_pk, msr, vm_data )
  ]->
   [
   Quote_Request( ~ppid, 'burrito_enclave_sgx_measurement',
                  h(<'report_data', psp_sn_pk, msr, vm_data>)
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Guest_VM_Request_Report[color=#4c5454]:
   [
   !SEV_PSP_Guest_Running( ~cpu_id, psp_sn_pk, 'burrito_guest_vm', ~cik ),
   Fr( ~timestamp )
   ]
  --[ Guest_VM_Request_Report( psp_sn_pk, ~timestamp ) ]->
   [
   Out( <<'burrito_report', ~timestamp>, 
         h(<'report_request', <'burrito_report', ~timestamp>, ~cik>)>
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) RP_Verify_Quote[color=#99c9b7]:
   [
   !Intel_RoT_Pk( pk(~intel_rot_ltk) ),
   In( <
        <<'sgx_quote', $measurement, ~ppid, report_data>, 
         sign(<'sgx_quote', $measurement, ~ppid, report_data>, ~qe_ltk)>, 
        <'sgx_cert', pk(~qe_ltk), ~ppid>, 
        sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)>
   )
   ]
  --[
  RP_Verify_Quote( <'sgx_quote', $measurement, ~ppid, report_data> ),
  RP_QE_Ltk( ~qe_ltk, ~ppid )
  ]->
   [ ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_Intel_RoT[color=#f5b7b1]:
   [ !Intel_RoT_Ltk( ~intel_rot_ltk ) ]
  --[ Compromise_Intel_RoT( ) ]->
   [ Out( ~intel_rot_ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_SGX_QE[color=#f5b7b1]:
   [ !QE_Ltk( ~ppid, platform_data, ~qe_ltk ) ]
  --[ Compromise_SGX_QE( ~ppid ) ]->
   [ Out( ~qe_ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Adversary_Request_Quote[color=#f5b7b1]:
   [ In( <~ppid, $sgx_measurement, report_data> ) ]
  --[
  Neq( $sgx_measurement, 'burrito_enclave_sgx_measurement' ),
  Adversary_Request_Quote( )
  ]->
   [ Quote_Request( ~ppid, $sgx_measurement, report_data ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_AMD_RoT[color=#f5b7b1]:
   [ !AMD_RoT_Ltk( ~amd_rot_ltk ) ]
  --[ Compromise_AMD_RoT( ) ]->
   [ Out( ~amd_rot_ltk ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Compromise_SEV_PSP[color=#f5b7b1]:
   [ !PSP_Ltk( ~cpu_id, ~psp_sn ), !PSP_Pk( ~cpu_id, psp_pk ) ]
  --[ Compromise_SEV_PSP( psp_pk ) ]->
   [ Out( ~psp_sn ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Adversary_Extract_SEV_Secret[color=#f5b7b1]:
   [ !SEV_PSP_Guest_Running( ~cpu_id, psp_sn_pk, $vm_dig, ~guest_secret ) ]
  --[
  Neq( $vm_dig, 'burrito_guest_vm' ),
  Adversary_Extract_SEV_Secret( $vm_dig, ~guest_secret )
  ]->
   [ Out( ~guest_secret ) ]

  /* has exactly the trivial AC variant */

restriction Inequality:
  "∀ x #i. (Neq( x, x ) @ #i) ⇒ (⊥)"
  // safety formula

restriction Intel_RoT_Initializes_Once:
  "∀ #i #j.
    ((Intel_RoT_Initialize( ) @ #i) ∧ (Intel_RoT_Initialize( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction AMD_RoT_Initializes_Once:
  "∀ #i #j.
    ((AMD_RoT_Initialize( ) @ #i) ∧ (AMD_RoT_Initialize( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction One_QE:
  "∀ #i #j.
    ((SGX_QE_Initialize( ) @ #i) ∧ (SGX_QE_Initialize( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction One_PSP:
  "∀ #i #j.
    ((SEV_PSP_Initialize( ) @ #i) ∧ (SEV_PSP_Initialize( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction One_PSP_Guest:
  "∀ #i #j.
    ((SEV_PSP_Initialize_Guest( ) @ #i) ∧
     (SEV_PSP_Initialize_Guest( ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction One_GO:
  "∀ c1 c2 #i #j.
    ((TO_Enclave_Verify_Platform_Cert( c1 ) @ #i) ∧
     (TO_Enclave_Verify_Platform_Cert( c2 ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction One_RP:
  "∀ q1 q2 #i #j.
    ((RP_Verify_Quote( q1 ) @ #i) ∧ (RP_Verify_Quote( q2 ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

restriction One_VM:
  "∀ t1 t2 k1 k2 #i #j.
    ((Guest_VM_Request_Report( k1, t1 ) @ #i) ∧
     (Guest_VM_Request_Report( k2, t2 ) @ #j)) ⇒
    (#i = #j)"
  // safety formula

lemma lm_sev_amd_rot_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ltk #i.
    (AMD_RoT_Key( ltk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk #i.
  (AMD_RoT_Key( ltk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧ (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sev_psp_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ cpuid ltk ltk_pk #i.
    (SEV_PSP_Ltk( cpuid, ltk, ltk_pk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_SEV_PSP( ltk_pk ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ cpuid ltk ltk_pk #i.
  (SEV_PSP_Ltk( cpuid, ltk, ltk_pk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧
  (∀ #j. (Compromise_SEV_PSP( ltk_pk ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sev_enclave_secrets_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ k ss kek kik tek tik #i.
    (TO_Enclave_Secrets( k, ss, kek, kik, tek, tik ) @ #i) ⇒
    (((((((¬(∃ #j. !KU( ss ) @ #j)) ∧ (¬(∃ #j. !KU( kek ) @ #j))) ∧
         (¬(∃ #j. !KU( kik ) @ #j))) ∧
        (¬(∃ #j. !KU( tek ) @ #j))) ∧
       (¬(∃ #j. !KU( tik ) @ #j))) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k ss kek kik tek tik #i.
  (TO_Enclave_Secrets( k, ss, kek, kik, tek, tik ) @ #i)
 ∧
  (((∃ #j. (!KU( ss ) @ #j)) ∨
    (∃ #j. (!KU( kek ) @ #j)) ∨
    (∃ #j. (!KU( kik ) @ #j)) ∨
    (∃ #j. (!KU( tek ) @ #j)) ∨
    (∃ #j. (!KU( tik ) @ #j)))) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sev_guest_secret_secrecy_weak [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    (((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ k1 #j. Compromise_SEV_PSP( k1 ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ k1 #j. (Compromise_SEV_PSP( k1 ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sev_guest_secret_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    (((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sev_public_key_agreement [reuse, heuristic=C]:
  all-traces
  "∀ k1 k2 t s #i #j.
    ((TO_Enclave_Guest_Secrets( k1, t, s ) @ #i) ∧
     (SEV_PSP_Secrets( k2, t, s ) @ #j)) ⇒
    (((k1 = k2) ∨ (∃ #j.1. Compromise_AMD_RoT( ) @ #j.1)) ∨
     (∃ #j.1. Compromise_SEV_PSP( k1 ) @ #j.1))"
/*
guarded formula characterizing all counter-examples:
"∃ k1 k2 t s #i #j.
  (TO_Enclave_Guest_Secrets( k1, t, s ) @ #i) ∧
  (SEV_PSP_Secrets( k2, t, s ) @ #j)
 ∧
  (¬(k1 = k2)) ∧
  (∀ #j.1. (Compromise_AMD_RoT( ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_SEV_PSP( k1 ) @ #j.1) ⇒ ⊥)"
*/
by sorry

lemma lm_sgx_intel_rot_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ltk #i.
    (Intel_RoT_Key( ltk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk #i.
  (Intel_RoT_Key( ltk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧ (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sgx_qe_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ppid ltk #i.
    (SGX_QE_Ltk( ppid, ltk ) @ #i) ⇒
    ((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid ltk #i.
  (SGX_QE_Ltk( ppid, ltk ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧ (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sgx_rp_qe_ltk_authenticity [reuse, heuristic=C]:
  all-traces
  "∀ ltk ppid #i.
    (RP_QE_Ltk( ltk, ppid ) @ #i) ⇒
    ((∃ #j. SGX_QE_Ltk( ppid, ltk ) @ #j) ∨
     (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk ppid #i.
  (RP_QE_Ltk( ltk, ppid ) @ #i)
 ∧
  (∀ #j. (SGX_QE_Ltk( ppid, ltk ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sgx_rp_qe_ltk_secrecy [reuse, heuristic=C]:
  all-traces
  "∀ ltk ppid #i.
    (RP_QE_Ltk( ltk, ppid ) @ #i) ⇒
    (((¬(∃ #j. !KU( ltk ) @ #j)) ∨ (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
     (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ltk ppid #i.
  (RP_QE_Ltk( ltk, ppid ) @ #i)
 ∧
  (∃ #j. (!KU( ltk ) @ #j)) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sgx_quote_authenticity_weak [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    (((∃ v d k #j.
        (rd = h(<'report_data', k, d, v>)) ∧
        (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
      (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
     (∃ ppid_1 #j. Compromise_SGX_QE( ppid_1 ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ ppid_1 #j. (Compromise_SGX_QE( ppid_1 ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_sgx_quote_authenticity [reuse, heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    (((∃ v d k #j.
        (rd = h(<'report_data', k, d, v>)) ∧
        (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
      (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_burrito_quote_integrity_weak [heuristic=o "oracle.py",
                                       hide_lemma=lm_sev_enclave_secrets_secrecy,
                                       hide_lemma=lm_sev_psp_ltk_secrecy,
                                       hide_lemma=lm_sev_amd_rot_ltk_secrecy,
                                       hide_lemma=lm_sgx_intel_rot_ltk_secrecy,
                                       hide_lemma=lm_sgx_qe_ltk_secrecy,
                                       hide_lemma=lm_sgx_rp_qe_ltk_authenticity,
                                       hide_lemma=lm_sgx_rp_qe_ltk_secrecy]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ ppid1 #j. Compromise_SGX_QE( ppid1 ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ k1 #j. Compromise_SEV_PSP( k1 ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ ppid1 #j. (Compromise_SGX_QE( ppid1 ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ k1 #j. (Compromise_SEV_PSP( k1 ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma lm_burrito_quote_integrity_strong [heuristic=o "oracle.py",
                                         hide_lemma=lm_sev_enclave_secrets_secrecy,
                                         hide_lemma=lm_sev_psp_ltk_secrecy,
                                         hide_lemma=lm_sev_amd_rot_ltk_secrecy,
                                         hide_lemma=lm_sgx_intel_rot_ltk_secrecy,
                                         hide_lemma=lm_sgx_qe_ltk_secrecy,
                                         hide_lemma=lm_sgx_rp_qe_ltk_authenticity,
                                         hide_lemma=lm_sgx_rp_qe_ltk_secrecy]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
by sorry

lemma ex_can_generate_burrito_quote:
  exists-trace
  "∃ ppid k ts m #i #j.
    (((((RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', 
                           ppid, 
                           h(<'report_data', k, <m, 'burrito_guest_vm'>, 'burrito_report', ts>)>
         ) @ #i) ∧
        (Guest_VM_Request_Report( k, ts ) @ #j)) ∧
       (¬(∃ #j.1. Compromise_Intel_RoT( ) @ #j.1))) ∧
      (¬(∃ #j.1. Compromise_SGX_QE( ppid ) @ #j.1))) ∧
     (¬(∃ #j.1. Compromise_AMD_RoT( ) @ #j.1))) ∧
    (¬(∃ #j.1. Compromise_SEV_PSP( k ) @ #j.1))"
/*
guarded formula characterizing all satisfying traces:
"∃ ppid k ts m #i #j.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, 'burrito_report', ts>)>
   ) @ #i) ∧
  (Guest_VM_Request_Report( k, ts ) @ #j)
 ∧
  (∀ #j.1. (Compromise_Intel_RoT( ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_SGX_QE( ppid ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_AMD_RoT( ) @ #j.1) ⇒ ⊥) ∧
  (∀ #j.1. (Compromise_SEV_PSP( k ) @ #j.1) ⇒ ⊥)"
*/
simplify
solve( (∃ v d k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, 'burrito_report', 
             ~timestamp>) =
          h(<'report_data', k.1, d, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
         (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
         (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
    case case_1
    solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
           (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
      case case_1
      solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
             (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
        case case_1
        solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
          case Intel_RoT_Initialize
          solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            solve( !SEV_PSP_Guest_Running( ~cpu_id, k, 'burrito_guest_vm', ~cik
                   ) ▶₀ #j )
              case SEV_PSP_Launch_Guest
              solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( TO_Enclave_VM_Provisioned( 'g'^~psp_sn, ~ppid,
                                                  <m, 'burrito_guest_vm'>, ~cik.1
                       ) ▶₀ #j.1 )
                  case TO_Enclave_Provision_VM
                  solve( (∀ #j. (!KU( ~cik.1 ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                    case case_1
                    solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                            (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                            (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                            (∀ #j. (!KU( ~tek.1 ) @ #j) ⇒ ⊥) ∧
                            (∀ #j. (!KU( ~tik.1 ) @ #j) ⇒ ⊥))  ∥
                           (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                             (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                        case case_1
                        solve( !KU( ~ppid ) @ #vk.7 )
                          case Intel_RoT_Certify
                          solve( !KU( ~timestamp ) @ #vk.20 )
                            case Guest_VM_Request_Report
                            solve( !KU( ~mnonce ) @ #vk.32 )
                              case SEV_PSP_Initialize_Guest
                              solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                                                h(<'report_data', 'g'^~psp_sn, <~mnonce, 'burrito_guest_vm'>, 
                                                   'burrito_report', ~timestamp>)
                                               >,
                                               ~qe_ltk)
                                     ) @ #vk.15 )
                                case SGX_QE_Generate_Quote_case_1
                                solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                                       ) @ #vk.20 )
                                  case Intel_RoT_Certify
                                  solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.38 )
                                    case AMD_RoT_Certify
                                    solve( !KU( pk(~qe_ltk) ) @ #vk.21 )
                                      case Intel_RoT_Certify
                                      solve( !KU( h(<'report_data', 'g'^~psp_sn, 
                                                     <~mnonce, 'burrito_guest_vm'>, 'burrito_report', 
                                                     ~timestamp>)
                                             ) @ #vk.21 )
                                        case SGX_QE_Generate_Quote
                                        solve( !KU( h(<'report_request', <'burrito_report', ~timestamp>, 
                                                       ~cik.1>)
                                               ) @ #vk.23 )
                                          case Guest_VM_Request_Report
                                          solve( !KU( senc(<'launch_secret', 
                                                            h(<'launch_measurement', ~mnonce, 
                                                               'burrito_guest_vm', ~tik>), 
                                                            ~cik>,
                                                           ~tek)
                                                 ) @ #vk.26 )
                                            case TO_Enclave_Provision_VM
                                            solve( !KU( h(<
                                                           <'launch_secret', 
                                                            h(<'launch_measurement', ~mnonce, 
                                                               'burrito_guest_vm', ~tik>), 
                                                            ~cik>, 
                                                           ~tik>)
                                                   ) @ #vk.27 )
                                              case TO_Enclave_Provision_VM
                                              solve( !KU( senc(<'transport_keys', ~tek, ~tik>,
                                                               h(<'sev_kek', z>))
                                                     ) @ #vk.31 )
                                                case TO_Enclave_Deploy_VM
                                                solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                                               h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                                                       ) @ #vk.33 )
                                                  case TO_Enclave_Deploy_VM
                                                  solve( !KU( h(<'launch_measurement', ~mnonce, 
                                                                 'burrito_guest_vm', ~tik>)
                                                         ) @ #vk.35 )
                                                    case SEV_PSP_Initialize_Guest
                                                    solve( !KU( 'g'^~psp_sn ) @ #vk.38 )
                                                      case AMD_RoT_Certify
                                                      solve( !KU( 'g'^~go_sn ) @ #vk.35 )
                                                        case TO_Enclave_Deploy_VM
                                                        SOLVED // trace found
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma ex_can_verify_quote_created_by_adversary:
  exists-trace
  "∃ ppid #i.
    RP_Verify_Quote( <'sgx_quote', 'arbitrary_sgx_measurement', ppid, 
                      'arbitrary_data'>
    ) @ #i"
/*
guarded formula characterizing all satisfying traces:
"∃ ppid #i.
  (RP_Verify_Quote( <'sgx_quote', 'arbitrary_sgx_measurement', ppid, 
                     'arbitrary_data'>
   ) @ #i)"
*/
simplify
solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
  case case_1
  solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
         (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
    case case_1
    solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
           (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
      case case_1
      solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
        case Intel_RoT_Initialize
        solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
               (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
          case case_1
          solve( !KU( ~ppid ) @ #vk.7 )
            case Intel_RoT_Certify
            solve( !KU( sign(<'sgx_quote', 'arbitrary_sgx_measurement', ~ppid, 
                              'arbitrary_data'>,
                             ~qe_ltk)
                   ) @ #vk.12 )
              case SGX_QE_Generate_Quote
              solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                     ) @ #vk.17 )
                case Intel_RoT_Certify
                solve( !KU( pk(~qe_ltk) ) @ #vk.17 )
                  case Intel_RoT_Certify
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma ex_adversary_can_launch_sev_guest:
  exists-trace
  "((∃ #i. SEV_PSP_Launch_Guest( ) @ #i) ∧
    (¬(∃ #j. Compromise_AMD_RoT( ) @ #j))) ∧
   (¬(∃ c #j. TO_Enclave_Verify_Platform_Cert( c ) @ #j))"
/*
guarded formula characterizing all satisfying traces:
"(∃ #i. (SEV_PSP_Launch_Guest( ) @ #i)) ∧
 (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
 (∀ c #j. (TO_Enclave_Verify_Platform_Cert( c ) @ #j) ⇒ ⊥)"
*/
simplify
solve( SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik,
                                  $vm_dig, measure
       ) ▶₁ #i )
  case SEV_PSP_Initialize_Guest
  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
    case case_1
    solve( !KU( senc(<'launch_secret', 
                      h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~guest_secret>,
                     ~tek)
           ) @ #vk.1 )
      case c_senc
      solve( !KU( ~tek ) @ #vk.11 )
        case Compromise_Intel_RoT
        solve( (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥)  ∥
               (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
          case case_2
          solve( !Intel_RoT_Ltk( ~intel_rot_ltk ) ▶₀ #j )
            case Intel_RoT_Initialize
            solve( !KU( ~guest_secret ) @ #vk.15 )
              case Compromise_Intel_RoT
              solve( !KU( h(<
                             <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), 
                              ~guest_secret>, 
                             ~tik>)
                     ) @ #vk.4 )
                case c_h
                solve( !KU( ~tik ) @ #vk.16 )
                  case Compromise_Intel_RoT
                  solve( !KU( senc(<'transport_keys', ~guest_secret, ~guest_secret>,
                                   h(<'sev_kek', z>))
                         ) @ #vk.10 )
                    case c_senc
                    solve( !KU( h(<<'transport_keys', ~guest_secret, ~guest_secret>, 
                                   h(<'sev_kik', z>)>)
                           ) @ #vk.13 )
                      case c_h
                      solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~guest_secret>)
                             ) @ #vk.17 )
                        case SEV_PSP_Initialize_Guest
                        solve( !KU( h(<'sev_kek', z>) ) @ #vk.19 )
                          case c_h
                          solve( !KU( h(<'sev_kik', z>) ) @ #vk.21 )
                            case c_h
                            solve( splitEqs(1) )
                              case split_case_1
                              solve( !KU( go_sn_pk^~psp_sn ) @ #vk.24 )
                                case AMD_RoT_Certify
                                solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                                       (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                                  case case_1
                                  SOLVED // trace found
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma ex_adversary_can_launch_sev_guest_and_extract_secret:
  exists-trace
  "(∃ s #i. Adversary_Extract_SEV_Secret( 'arbitrary_vmc', s ) @ #i) ∧
   (¬(∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all satisfying traces:
"(∃ s #i. (Adversary_Extract_SEV_Secret( 'arbitrary_vmc', s ) @ #i)) ∧
 (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !SEV_PSP_Guest_Running( ~cpu_id, psp_sn_pk, 'arbitrary_vmc',
                               ~guest_secret
       ) ▶₀ #i )
  case SEV_PSP_Launch_Guest
  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
    case case_1
    solve( !KU( senc(<'launch_secret', 
                      h(<'launch_measurement', ~mnonce, 'arbitrary_vmc', ~tik>), ~guest_secret
                     >,
                     ~tek)
           ) @ #vk.1 )
      case TO_Enclave_Provision_VM
      solve( ((∀ #j. (!KU( z.1 ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( h(<'sev_kek', z.1>) ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( h(<'sev_kik', z.1>) ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
             (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
             (∃ #j. (Compromise_SEV_PSP( psp_sn_pk ) @ #j)) )
        case case_1
        solve( (psp_sn_pk = 'g'^~psp_sn)  ∥
               (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
               (∃ #j. (Compromise_SEV_PSP( psp_sn_pk ) @ #j)) )
          case case_1
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
              case case_1
              solve( !KU( ~mnonce ) @ #vk.11 )
                case SEV_PSP_Initialize_Guest
                solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.17 )
                  case AMD_RoT_Certify
                  solve( !KU( h(<
                                 <'launch_secret', 
                                  h(<'launch_measurement', ~mnonce, 'arbitrary_vmc', ~tik>), ~guest_secret
                                 >, 
                                 ~tik>)
                         ) @ #vk.5 )
                    case TO_Enclave_Provision_VM
                    solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>))
                           ) @ #vk.10 )
                      case TO_Enclave_Deploy_VM
                      solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                     h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                             ) @ #vk.12 )
                        case TO_Enclave_Deploy_VM
                        solve( !KU( h(<'launch_measurement', ~mnonce, 'arbitrary_vmc', ~tik>)
                               ) @ #vk.14 )
                          case SEV_PSP_Initialize_Guest
                          solve( !KU( 'g'^~psp_sn ) @ #vk.17 )
                            case AMD_RoT_Certify
                            solve( !KU( 'g'^~go_sn ) @ #vk.14 )
                              case TO_Enclave_Deploy_VM
                              SOLVED // trace found
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma ex_can_launch_sev_guest_without_adversary:
  exists-trace
  "((∃ #i. SEV_PSP_Launch_Guest( ) @ #i) ∧
    (¬(∃ #j. Compromise_AMD_RoT( ) @ #j))) ∧
   (¬(∃ k #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all satisfying traces:
"(∃ #i. (SEV_PSP_Launch_Guest( ) @ #i)) ∧
 (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
 (∀ k #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( SEV_PSP_Guest_Initialized( ~cpu_id, psp_sn_pk, ~tek, ~tik,
                                  $vm_dig, measure
       ) ▶₁ #i )
  case SEV_PSP_Initialize_Guest
  solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
         (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
    case case_1
    solve( !KU( senc(<'launch_secret', 
                      h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~guest_secret>,
                     ~tek)
           ) @ #vk.1 )
      case TO_Enclave_Provision_VM
      solve( ((∀ #j. (!KU( z.1 ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( h(<'sev_kek', z.1>) ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( h(<'sev_kik', z.1>) ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
              (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
             (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
             (∃ #j. (Compromise_SEV_PSP( psp_sn_pk ) @ #j)) )
        case case_1
        solve( (psp_sn_pk = 'g'^~psp_sn)  ∥
               (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
               (∃ #j. (Compromise_SEV_PSP( psp_sn_pk ) @ #j)) )
          case case_1
          solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
              case case_1
              solve( !KU( ~mnonce ) @ #vk.11 )
                case SEV_PSP_Initialize_Guest
                solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.17 )
                  case AMD_RoT_Certify
                  solve( !KU( h(<
                                 <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), 
                                  ~guest_secret>, 
                                 ~tik>)
                         ) @ #vk.5 )
                    case TO_Enclave_Provision_VM
                    solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>))
                           ) @ #vk.10 )
                      case TO_Enclave_Deploy_VM
                      solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                     h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                             ) @ #vk.12 )
                        case TO_Enclave_Deploy_VM
                        solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                               ) @ #vk.14 )
                          case SEV_PSP_Initialize_Guest
                          solve( !KU( 'g'^~psp_sn ) @ #vk.17 )
                            case AMD_RoT_Certify
                            solve( !KU( 'g'^~go_sn ) @ #vk.14 )
                              case TO_Enclave_Deploy_VM
                              SOLVED // trace found
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sgx_quote_authenticity_1 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                       ppid, rd>
     ) @ #i) ⇒
    (((∃ v d k #j.
        (rd = h(<'report_data', k, d, v>)) ∧
        (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
      (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                     ppid, rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
  case Intel_RoT_Initialize
  solve( !KU( ~ppid ) @ #vk.7 )
    case Intel_RoT_Certify
    solve( !KU( sign(<'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                      ~ppid, rd>,
                     ~qe_ltk)
           ) @ #vk.12 )
      case SGX_QE_Generate_Quote
      solve( !KU( pk(~qe_ltk) ) @ #vk.16 )
        case Intel_RoT_Certify
        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
               ) @ #vk.17 )
          case Intel_RoT_Certify
          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
            case case_1
            solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                case case_1
                solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                  case case_1
                  SOLVED // trace found
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sgx_quote_authenticity_2 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    ((∃ #j. Compromise_Intel_RoT( ) @ #j) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d k #j.
         (rd = h(<'report_data', k, d, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k, d, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
    case Intel_RoT_Initialize
    solve( !KU( ~ppid ) @ #vk.7 )
      case Intel_RoT_Certify
      solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                        h(<'report_data', k, d, v>)>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case SGX_QE_Generate_Quote_case_1
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
              case case_1
              solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                     (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'report_data', k, <~mnonce, $vm_dig>, v>) ) @ #vk.14 )
                  case SGX_QE_Generate_Quote
                  solve( TO_Enclave_VM_Provisioned( k, ~ppid, <~mnonce, $vm_dig>, ~cik
                         ) ▶₀ #j )
                    case TO_Enclave_Provision_VM
                    solve( !KU( h(<'report_request', v, ~cik>) ) @ #vk.18 )
                      case Guest_VM_Request_Report
                      solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                             (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                        case case_1
                        solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                               (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                          case case_1
                          solve( !KU( ~mnonce ) @ #vk.20 )
                            case Compromise_AMD_RoT
                            solve( !KU( h(<'launch_measurement', ~amd_rot_ltk, $vm_dig, ~tik>)
                                   ) @ #vk.21 )
                              case c_h
                              solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.29 )
                                case AMD_RoT_Certify
                                solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                                        (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                                        (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                                       (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                                  case case_2
                                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                                    case case_2
                                    solve( !KU( senc(<'launch_secret', 
                                                      h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', 
                                                         ~tik.1>), 
                                                      ~cik>,
                                                     ~tek.1)
                                           ) @ #vk.32 )
                                      case c_senc
                                      solve( !KU( h(<
                                                     <'launch_secret', 
                                                      h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', 
                                                         ~tik.1>), 
                                                      ~cik>, 
                                                     ~tik.1>)
                                             ) @ #vk.33 )
                                        case c_h
                                        solve( !KU( senc(<'transport_keys', ~tek.1, ~tik.1>,
                                                         h(<'sev_kek', z>))
                                               ) @ #vk.37 )
                                          case TO_Enclave_Deploy_VM
                                          solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                                         h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                                                 ) @ #vk.39 )
                                            case TO_Enclave_Deploy_VM
                                            solve( !KU( ~timestamp ) @ #vk.42 )
                                              case Guest_VM_Request_Report
                                              solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                                                case case_2
                                                solve( !KU( ~tik ) @ #vk.44 )
                                                  case TO_Enclave_Deploy_VM
                                                  solve( !KU( 'g'^~psp_sn ) @ #vk.40 )
                                                    case AMD_RoT_Certify
                                                    solve( !AMD_RoT_Ltk( ~amd_rot_ltk.1 ) ▶₀ #j.1 )
                                                      case AMD_RoT_Initialize
                                                      solve( !KU( ~tek ) @ #vk.47 )
                                                        case TO_Enclave_Deploy_VM
                                                        solve( !KU( h(<'launch_measurement', ~mnonce, 
                                                                       'burrito_guest_vm', ~tik>)
                                                               ) @ #vk.50 )
                                                          case SEV_PSP_Initialize_Guest
                                                          solve( !KU( ~cik ) @ #vk.51 )
                                                            case TO_Enclave_Provision_VM
                                                            solve( !KU( 'g'^~go_sn ) @ #vk.46 )
                                                              case TO_Enclave_Deploy_VM
                                                              solve( !PSP_Ltk( ~cpu_id, ~psp_sn.1 ) ▶₀ #j.2 )
                                                                case SEV_PSP_Initialize
                                                                solve( !PSP_Pk( ~cpu_id, 'g'^~psp_sn
                                                                       ) ▶₁ #j.2 )
                                                                  case SEV_PSP_Initialize
                                                                  solve( !KU( h(<'sev_kek', 
                                                                                 'g'^(~go_sn*~psp_sn)>)
                                                                         ) @ #vk.52 )
                                                                    case c_h
                                                                    solve( !KU( 'g'^(~go_sn*~psp_sn)
                                                                           ) @ #vk.55 )
                                                                      case TO_Enclave_Deploy_VM
                                                                      solve( !KU( ~psp_sn ) @ #vk.56 )
                                                                        case Compromise_SEV_PSP
                                                                        SOLVED // trace found
                                                                      qed
                                                                    qed
                                                                  qed
                                                                qed
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sgx_quote_authenticity_3 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    ((∃ v d k #j.
       (rd = h(<'report_data', k, d, v>)) ∧
       (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
     (∃ #j. Compromise_SGX_QE( ppid ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d k #j.
         (rd = h(<'report_data', k, d, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k, d, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_2
  solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
    case Intel_RoT_Initialize
    solve( !KU( ~ppid ) @ #vk.7 )
      case Adversary_Extract_SEV_Secret
      solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                        rd>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case c_sign
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case AMD_RoT_Initialize
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case c_sign
            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
              case case_3
              solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                     (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                case case_2
                solve( !Intel_RoT_Ltk( ~intel_rot_ltk.1 ) ▶₀ #j )
                  case Intel_RoT_Initialize
                  solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                    case case_2
                    solve( !KU( senc(<'launch_secret', 
                                      h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), ~ppid>,
                                     ~tek)
                           ) @ #vk.17 )
                      case TO_Enclave_Provision_VM
                      solve( !KU( h(<
                                     <'launch_secret', h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), 
                                      ~ppid>, 
                                     ~tik>)
                             ) @ #vk.18 )
                        case TO_Enclave_Provision_VM
                        solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>))
                               ) @ #vk.22 )
                          case TO_Enclave_Deploy_VM
                          solve( !KU( h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', z>)>)
                                 ) @ #vk.24 )
                            case TO_Enclave_Deploy_VM
                            solve( splitEqs(2) )
                              case split_case_3
                              solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                                case case_1
                                solve( !KU( ~qe_ltk ) @ #vk.26 )
                                  case Compromise_AMD_RoT
                                  solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                                    case case_2
                                    solve( !KU( ~intel_rot_ltk ) @ #vk.27 )
                                      case Compromise_Intel_RoT
                                      solve( !KU( ~mnonce ) @ #vk.29 )
                                        case SEV_PSP_Initialize_Guest
                                        solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                                               ) @ #vk.30 )
                                          case SEV_PSP_Initialize_Guest
                                          solve( !KU( sign(<'sev_cert', x^x.2>, ~qe_ltk) ) @ #vk.35 )
                                            case AMD_RoT_Certify
                                            solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                                                    (∀ #j.
                                                      (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j)
                                                     ⇒
                                                      ⊥) ∧
                                                    (∀ #j.
                                                      (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j)
                                                     ⇒
                                                      ⊥) ∧
                                                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                                                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                                                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                                              case case_1
                                              solve( (∀ #j. (!KU( ~qe_ltk.1 ) @ #j) ⇒ ⊥)  ∥
                                                     (∃ #j. (Compromise_SGX_QE( ~ppid.1 ) @ #j)) )
                                                case case_1
                                                solve( !KU( 'g'^~go_sn ) @ #vk.31 )
                                                  case TO_Enclave_Deploy_VM
                                                  solve( !KU( 'g'^~psp_sn ) @ #vk.35 )
                                                    case AMD_RoT_Certify
                                                    solve( !AMD_RoT_Ltk( ~amd_rot_ltk ) ▶₀ #j.1 )
                                                      case AMD_RoT_Initialize
                                                      SOLVED // trace found
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sgx_quote_authenticity_4 [heuristic=C]:
  all-traces
  "∀ ppid #i rd.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       rd>
     ) @ #i) ⇒
    ((∃ v d k #j.
       (rd = h(<'report_data', k, d, v>)) ∧
       (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)) ∨
     (∃ #j. Compromise_Intel_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid #i rd.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     rd>
   ) @ #i)
 ∧
  (∀ v d k #j.
    (rd = h(<'report_data', k, d, v>)) ∧
    (TO_Enclave_Generate_Report_For_VM( ppid, k, d, v ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d k #j.
         (rd = h(<'report_data', k, d, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k, d, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_3
  solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
    case Intel_RoT_Initialize
    solve( !KU( ~ppid ) @ #vk.7 )
      case Intel_RoT_Certify
      solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                        rd>,
                       ~qe_ltk)
             ) @ #vk.12 )
        case c_sign
        solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.15 )
            case Intel_RoT_Certify
            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
              case case_2
              solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                     (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                case case_1
                solve( !QE_Ltk( ~ppid, platform_data, ~qe_ltk.1 ) ▶₀ #j )
                  case SGX_QE_Initialize
                  solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                    case case_1
                    solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                      case case_2
                      solve( !KU( ~qe_ltk ) @ #vk.16 )
                        case Compromise_SGX_QE
                        SOLVED // trace found
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sev_guest_secret_secrecy_1 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'fake_burrito_guest_vm' ) @ #i) ⇒
    (((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'fake_burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( TO_Enclave_VM_Deployed( k, ~ppid, ~tek, ~tik,
                               'fake_burrito_guest_vm'
       ) ▶₀ #i )
  case TO_Enclave_Deploy_VM
  solve( !KU( ~mnonce ) @ #vk.1 )
    case SEV_PSP_Initialize_Guest
    solve( !KU( h(<'launch_measurement', ~mnonce, 'fake_burrito_guest_vm', 
                   ~tik>)
           ) @ #vk.2 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( ~cik ) @ #j )
        case Adversary_Extract_SEV_Secret
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.10 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                solve( !KU( senc(<'transport_keys', ~tek.1, ~tik>, h(<'sev_kek', z>))
                       ) @ #vk.13 )
                  case TO_Enclave_Deploy_VM
                  solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                 h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                         ) @ #vk.14 )
                    case TO_Enclave_Deploy_VM
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      solve( !KU( senc(<'launch_secret', 
                                        h(<'launch_measurement', ~mnonce, 'fake_burrito_guest_vm', ~tik>), 
                                        ~cik>,
                                       ~tek)
                             ) @ #vk.16 )
                        case TO_Enclave_Provision_VM
                        solve( !KU( h(<
                                       <'launch_secret', 
                                        h(<'launch_measurement', ~mnonce, 'fake_burrito_guest_vm', ~tik>), 
                                        ~cik>, 
                                       ~tik>)
                               ) @ #vk.17 )
                          case TO_Enclave_Provision_VM
                          solve( !KU( 'g'^~psp_sn ) @ #vk.16 )
                            case AMD_RoT_Certify
                            solve( !KU( 'g'^~go_sn ) @ #vk.17 )
                              case TO_Enclave_Deploy_VM
                              SOLVED // trace found
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sev_guest_secret_secrecy_2 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    ((∃ #j. Compromise_AMD_RoT( ) @ #j) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
  case case_1
  solve( TO_Enclave_VM_Deployed( k, ~ppid, ~tek, ~tik, 'burrito_guest_vm'
         ) ▶₀ #i )
    case TO_Enclave_Deploy_VM
    solve( !KU( ~mnonce ) @ #vk.1 )
      case SEV_PSP_Initialize_Guest
      solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
             ) @ #vk.2 )
        case SEV_PSP_Initialize_Guest
        solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.9 )
          case AMD_RoT_Certify
          solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                case case_1
                solve( !KU( senc(<'transport_keys', ~tek.1, ~tik>, h(<'sev_kek', z>))
                       ) @ #vk.13 )
                  case TO_Enclave_Deploy_VM
                  solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                 h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                         ) @ #vk.14 )
                    case TO_Enclave_Deploy_VM
                    solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                      case case_1
                      solve( !KU( 'g'^~psp_sn ) @ #vk.13 )
                        case AMD_RoT_Certify
                        solve( !KU( 'g'^~go_sn ) @ #vk.14 )
                          case TO_Enclave_Deploy_VM
                          SOLVED // trace found
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sev_guest_secret_secrecy_3 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    ((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧ (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
  case case_2
  solve( TO_Enclave_VM_Deployed( k, ~ppid, ~tek, ~tik, 'burrito_guest_vm'
         ) ▶₀ #i )
    case TO_Enclave_Deploy_VM
    solve( !KU( ~mnonce ) @ #vk.1 )
      case Compromise_AMD_RoT
      solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
             ) @ #vk.2 )
        case c_h
        solve( !KU( ~cik ) @ #j.1 )
          case TO_Enclave_Provision_VM
          solve( !AMD_RoT_Ltk( ~amd_rot_ltk ) ▶₀ #j )
            case AMD_RoT_Initialize
            solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.11 )
              case c_sign
              solve( splitEqs(2) )
                case split_case_1
                solve( ((∀ #j. (!KU( k^~go_sn ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', k^~go_sn>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
                  case case_2
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_2
                    solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                      case case_1
                      solve( !KU( ~tik ) @ #vk.13 )
                        case TO_Enclave_Deploy_VM
                        solve( !KU( ~tek ) @ #vk.14 )
                          case TO_Enclave_Deploy_VM
                          solve( !KU( h(<'sev_kek', k^~go_sn>) ) @ #vk.15 )
                            case c_h
                            solve( !KU( k^~go_sn ) @ #vk.18 )
                              case TO_Enclave_Deploy_VM
                              SOLVED // trace found
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_sev_guest_secret_secrecy_4 [heuristic=C]:
  all-traces
  "∀ k s #i.
    (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i) ⇒
    ((¬(∃ #j. !KU( s ) @ #j)) ∨ (∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ k s #i.
  (TO_Enclave_Provision_VM( k, s, 'burrito_guest_vm' ) @ #i)
 ∧
  (∃ #j. (!KU( s ) @ #j)) ∧ (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
  case case_3
  solve( TO_Enclave_VM_Deployed( k, ~ppid, ~tek, ~tik, 'burrito_guest_vm'
         ) ▶₀ #i )
    case TO_Enclave_Deploy_VM
    solve( !KU( ~mnonce ) @ #vk.1 )
      case Compromise_Intel_RoT
      solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
             ) @ #vk.2 )
        case c_h
        solve( !KU( ~cik ) @ #j.1 )
          case TO_Enclave_Provision_VM
          solve( !PSP_Ltk( ~cpu_id, ~psp_sn ) ▶₀ #j )
            case SEV_PSP_Initialize
            solve( !PSP_Pk( ~cpu_id, k ) ▶₁ #j )
              case SEV_PSP_Initialize
              solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk) ) @ #vk.11 )
                case AMD_RoT_Certify
                solve( ((∀ #j. (!KU( 'g'^(~go_sn*~psp_sn) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>) ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                        (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                       (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                  case case_3
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                           (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                      case case_1
                      solve( (∀ #j. (!KU( ~mnonce ) @ #j) ⇒ ⊥)  ∥
                             (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                        case case_2
                        solve( !KU( ~tik ) @ #vk.13 )
                          case TO_Enclave_Deploy_VM
                          solve( !KU( ~tek ) @ #vk.14 )
                            case TO_Enclave_Deploy_VM
                            solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                              case case_2
                              solve( !KU( 'g'^~psp_sn ) @ #vk.13 )
                                case AMD_RoT_Certify
                                solve( !Intel_RoT_Ltk( ~intel_rot_ltk ) ▶₀ #j.2 )
                                  case Intel_RoT_Initialize
                                  solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~psp_sn)>) ) @ #vk.15 )
                                    case c_h
                                    solve( !KU( 'g'^(~go_sn*~psp_sn) ) @ #vk.18 )
                                      case TO_Enclave_Deploy_VM
                                      solve( !KU( ~psp_sn ) @ #vk.19 )
                                        case Compromise_SEV_PSP
                                        SOLVED // trace found
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_burrito_quote_integrity_1 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                       ppid, h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                     ppid, h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( !KU( sign(<'sgx_quote', 'fake_burrito_enclave_sgx_measurement', 
                  ~ppid, h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>,
                 ~qe_ltk)
       ) @ #vk.10 )
  case SGX_QE_Generate_Quote
  solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
    case Intel_RoT_Initialize
    solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
           (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
      case case_1
      solve( !KU( ~ppid ) @ #vk.10 )
        case Intel_RoT_Certify
        solve( !KU( pk(~qe_ltk) ) @ #vk.16 )
          case Intel_RoT_Certify
          solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                 ) @ #vk.17 )
            case Intel_RoT_Certify
            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
              case case_1
              solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                     (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                case case_1
                solve( !KU( h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)
                       ) @ #vk.16 )
                  case c_h
                  solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                    case case_1
                    SOLVED // trace found
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_burrito_quote_integrity_2 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'fake_burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    (((((∃ ts #j.
          (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
        (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'fake_burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'fake_burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( TO_Enclave_VM_Provisioned( k, ~ppid, <m, 'fake_burrito_guest_vm'>,
                                    ~cik
         ) ▶₀ #j )
    case TO_Enclave_Provision_VM
    solve( !KU( h(<'report_request', d, ~cik>) ) @ #vk.18 )
      case c_h
      solve( !KU( ~cik ) @ #vk.31 )
        case Adversary_Extract_SEV_Secret
        solve( !KU( senc(<'launch_secret', 
                          h(<'launch_measurement', ~mnonce.1, $vm_dig, ~tik.1>), ~cik>,
                         ~tek.1)
               ) @ #vk.33 )
          case TO_Enclave_Provision_VM
          solve( !KU( h(<
                         <'launch_secret', 
                          h(<'launch_measurement', ~mnonce, 'fake_burrito_guest_vm', ~tik>), ~cik
                         >, 
                         ~tik>)
                 ) @ #vk.35 )
            case TO_Enclave_Provision_VM
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( (k = 'g'^~psp_sn)  ∥ (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
                  case case_1
                  solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                                    h(<'report_data', 'g'^~psp_sn, <~mnonce, 'fake_burrito_guest_vm'>, d>)>,
                                   ~qe_ltk)
                         ) @ #vk.20 )
                    case SGX_QE_Generate_Quote_case_1
                    solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>))
                           ) @ #vk.39 )
                      case TO_Enclave_Deploy_VM
                      solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                     h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                             ) @ #vk.40 )
                        case TO_Enclave_Deploy_VM
                        solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                               (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                          case case_1
                          solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
                            case Intel_RoT_Initialize
                            solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                              case case_1
                              solve( !KU( ~ppid ) @ #vk.21 )
                                case Intel_RoT_Certify
                                solve( !KU( pk(~qe_ltk) ) @ #vk.27 )
                                  case Intel_RoT_Certify
                                  solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                                         ) @ #vk.28 )
                                    case Intel_RoT_Certify
                                    solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                           (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                                           (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                                      case case_1
                                      solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                                             (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                                        case case_1
                                        solve( !KU( ~mnonce ) @ #vk.31 )
                                          case SEV_PSP_Initialize_Guest
                                          solve( !KU( h(<'launch_measurement', ~mnonce, 
                                                         'fake_burrito_guest_vm', ~tik>)
                                                 ) @ #vk.32 )
                                            case SEV_PSP_Initialize_Guest
                                            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                                              case case_1
                                              solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk)
                                                     ) @ #vk.38 )
                                                case AMD_RoT_Certify
                                                solve( !KU( h(<'report_data', 'g'^~psp_sn, 
                                                               <~mnonce, 'fake_burrito_guest_vm'>, d>)
                                                       ) @ #vk.31 )
                                                  case SGX_QE_Generate_Quote
                                                  solve( !KU( 'g'^~psp_sn ) @ #vk.38 )
                                                    case AMD_RoT_Certify
                                                    solve( !KU( 'g'^~go_sn ) @ #vk.40 )
                                                      case TO_Enclave_Deploy_VM
                                                      SOLVED // trace found
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_burrito_quote_integrity_3 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ #j. Compromise_Intel_RoT( ) @ #j) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( TO_Enclave_VM_Provisioned( k, ~ppid, <m, 'burrito_guest_vm'>, ~cik
         ) ▶₀ #j )
    case TO_Enclave_Provision_VM
    solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
           (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
           (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
      case case_1
      solve( !KU( h(<'report_request', d, ~cik>) ) @ #vk.18 )
        case Guest_VM_Request_Report
        solve( !KU( senc(<'launch_secret', 
                          h(<'launch_measurement', ~mnonce.1, 'burrito_guest_vm', ~tik.1>), ~cik>,
                         ~tek.1)
               ) @ #vk.30 )
          case TO_Enclave_Provision_VM
          solve( !KU( h(<
                         <'launch_secret', 
                          h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>), ~cik>, 
                         ~tik>)
                 ) @ #vk.32 )
            case TO_Enclave_Provision_VM
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( (k = 'g'^~psp_sn)  ∥ (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
                  case case_1
                  solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                                    h(<'report_data', 'g'^~psp_sn, <~mnonce, 'burrito_guest_vm'>, 
                                       'burrito_report', ~timestamp>)
                                   >,
                                   ~qe_ltk)
                         ) @ #vk.17 )
                    case SGX_QE_Generate_Quote_case_1
                    solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>))
                           ) @ #vk.35 )
                      case TO_Enclave_Deploy_VM
                      solve( !KU( h(<<'transport_keys', ~tek, ~tik>, 
                                     h(<'sev_kik', 'g'^(~go_sn*~psp_sn)>)>)
                             ) @ #vk.36 )
                        case TO_Enclave_Deploy_VM
                        solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                               (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                          case case_1
                          solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
                            case Intel_RoT_Initialize
                            solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                              case case_1
                              solve( !KU( ~ppid ) @ #vk.18 )
                                case Intel_RoT_Certify
                                solve( !KU( pk(~qe_ltk) ) @ #vk.24 )
                                  case Intel_RoT_Certify
                                  solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                                         ) @ #vk.25 )
                                    case Intel_RoT_Certify
                                    solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                           (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                                           (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                                      case case_1
                                      solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                                             (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                                        case case_1
                                        solve( !KU( ~mnonce ) @ #vk.28 )
                                          case SEV_PSP_Initialize_Guest
                                          solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', 
                                                         ~tik>)
                                                 ) @ #vk.29 )
                                            case SEV_PSP_Initialize_Guest
                                            solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                                   (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                                              case case_1
                                              solve( !KU( ~timestamp ) @ #vk.38 )
                                                case Guest_VM_Request_Report
                                                solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk)
                                                       ) @ #vk.36 )
                                                  case AMD_RoT_Certify
                                                  solve( !KU( h(<'report_data', 'g'^~psp_sn, 
                                                                 <~mnonce, 'burrito_guest_vm'>, 
                                                                 'burrito_report', ~timestamp>)
                                                         ) @ #vk.30 )
                                                    case SGX_QE_Generate_Quote
                                                    solve( !KU( 'g'^~psp_sn ) @ #vk.36 )
                                                      case AMD_RoT_Certify
                                                      solve( !KU( 'g'^~go_sn ) @ #vk.37 )
                                                        case TO_Enclave_Deploy_VM
                                                        SOLVED // trace found
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_burrito_quote_integrity_4 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_2
  solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                    h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>,
                   ~qe_ltk)
         ) @ #vk.11 )
    case c_sign
    solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
      case Intel_RoT_Initialize
      solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
             (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
        case case_2
        solve( !KU( ~ppid ) @ #vk.8 )
          case Adversary_Extract_SEV_Secret
          solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                 (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
            case case_1
            solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z>))
                   ) @ #vk.23 )
              case TO_Enclave_Deploy_VM
              solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                      (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                     (∃ #j. (Compromise_SEV_PSP( psp_sn_pk ) @ #j)) )
                case case_1
                solve( !KU( h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', z>)>)
                       ) @ #vk.25 )
                  case TO_Enclave_Deploy_VM
                  solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                    case case_1
                    solve( !KU( pk(~qe_ltk) ) @ #vk.19 )
                      case Intel_RoT_Certify
                      solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                             ) @ #vk.20 )
                        case c_sign
                        solve( !KU( ~intel_rot_ltk ) @ #vk.33 )
                          case Compromise_Intel_RoT
                          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                            case case_3
                            solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                              case case_2
                              solve( !KU( h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)
                                     ) @ #vk.20 )
                                case c_h
                                solve( !Intel_RoT_Ltk( ~intel_rot_ltk.1 ) ▶₀ #j )
                                  case Intel_RoT_Initialize
                                  solve( !KU( ~qe_ltk ) @ #vk.22 )
                                    case Compromise_SGX_QE
                                    solve( !KU( senc(<'launch_secret', 
                                                      h(<'launch_measurement', ~mnonce, $vm_dig.1, ~tik>), 
                                                      ~ppid>,
                                                     ~tek)
                                           ) @ #vk.24 )
                                      case TO_Enclave_Provision_VM
                                      solve( (psp_sn_pk = 'g'^~psp_sn)  ∥
                                             (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                                             (∃ #j. (Compromise_SEV_PSP( psp_sn_pk ) @ #j)) )
                                        case case_1
                                        solve( !KU( h(<
                                                       <'launch_secret', 
                                                        h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>), 
                                                        ~ppid>, 
                                                       ~tik>)
                                               ) @ #vk.25 )
                                          case TO_Enclave_Provision_VM
                                          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                                 (∃ #j. (Compromise_SGX_QE( ~ppid.1 ) @ #j)) )
                                            case case_2
                                            solve( !KU( ~mnonce ) @ #vk.43 )
                                              case SEV_PSP_Initialize_Guest
                                              solve( !KU( h(<'launch_measurement', ~mnonce, $vm_dig, ~tik>)
                                                     ) @ #vk.44 )
                                                case SEV_PSP_Initialize_Guest
                                                solve( !QE_Ltk( ~ppid.1, platform_data, ~qe_ltk.1 ) ▶₀ #j.1 )
                                                  case SGX_QE_Initialize
                                                  solve( !KU( sign(<'sev_cert', 'g'^~psp_sn>, ~amd_rot_ltk)
                                                         ) @ #vk.35 )
                                                    case AMD_RoT_Certify
                                                    solve( !KU( 'g'^~go_sn ) @ #vk.30 )
                                                      case TO_Enclave_Deploy_VM
                                                      solve( !KU( 'g'^~psp_sn ) @ #vk.35 )
                                                        case AMD_RoT_Certify
                                                        SOLVED // trace found
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_burrito_quote_integrity_5 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
      (∃ #j. Compromise_AMD_RoT( ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_3
  solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                    h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>,
                   ~qe_ltk)
         ) @ #vk.11 )
    case c_sign
    solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
      case Intel_RoT_Initialize
      solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
             (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
        case case_1
        solve( !KU( ~ppid ) @ #vk.8 )
          case Intel_RoT_Certify
          solve( !KU( pk(~qe_ltk) ) @ #vk.14 )
            case Intel_RoT_Certify
            solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                   ) @ #vk.15 )
              case Intel_RoT_Certify
              solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                     (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                case case_2
                solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                       (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                  case case_1
                  solve( !KU( h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)
                         ) @ #vk.14 )
                    case c_h
                    solve( !QE_Ltk( ~ppid, platform_data, ~qe_ltk.1 ) ▶₀ #j )
                      case SGX_QE_Initialize
                      solve( !KU( ~qe_ltk ) @ #vk.16 )
                        case Compromise_SGX_QE
                        solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                               (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                          case case_2
                          SOLVED // trace found
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_burrito_quote_integrity_6 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
      (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
     (∃ #j. Compromise_SEV_PSP( k ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SEV_PSP( k ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( TO_Enclave_VM_Provisioned( k, ~ppid, <m, 'burrito_guest_vm'>, ~cik
         ) ▶₀ #j )
    case TO_Enclave_Provision_VM
    solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
           (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
           (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
      case case_1
      solve( !KU( h(<'report_request', d, ~cik>) ) @ #vk.18 )
        case Guest_VM_Request_Report
        solve( !KU( senc(<'launch_secret', 
                          h(<'launch_measurement', ~mnonce.1, 'burrito_guest_vm', ~tik.1>), ~cik>,
                         ~tek.1)
               ) @ #vk.30 )
          case TO_Enclave_Provision_VM
          solve( !KU( h(<
                         <'launch_secret', 
                          h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>), ~cik>, 
                         ~tik>)
                 ) @ #vk.32 )
            case TO_Enclave_Provision_VM
            solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                    (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                   (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                   (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
              case case_1
              solve( (∀ #j. (!KU( ~psp_sn ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_SEV_PSP( 'g'^~psp_sn ) @ #j)) )
                case case_1
                solve( (k = 'g'^~psp_sn)  ∥ (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                       (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
                  case case_2
                  solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                                    h(<'report_data', k, <~mnonce, 'burrito_guest_vm'>, 'burrito_report', 
                                       ~timestamp>)
                                   >,
                                   ~qe_ltk)
                         ) @ #vk.17 )
                    case SGX_QE_Generate_Quote_case_1
                    solve( !KU( senc(<'transport_keys', ~tek, ~tik>, h(<'sev_kek', z.1>))
                           ) @ #vk.35 )
                      case TO_Enclave_Deploy_VM
                      solve( !KU( h(<<'transport_keys', ~tek, ~tik>, h(<'sev_kik', z>)>)
                             ) @ #vk.36 )
                        case TO_Enclave_Deploy_VM
                        solve( (∀ #j. (!KU( ~amd_rot_ltk.1 ) @ #j) ⇒ ⊥)  ∥
                               (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                          case case_2
                          solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
                            case Intel_RoT_Initialize
                            solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                              case case_1
                              solve( !KU( ~ppid ) @ #vk.18 )
                                case Intel_RoT_Certify
                                solve( !KU( pk(~qe_ltk) ) @ #vk.24 )
                                  case Intel_RoT_Certify
                                  solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                                         ) @ #vk.25 )
                                    case Intel_RoT_Certify
                                    solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                           (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                                           (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                                      case case_1
                                      solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                                             (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                                        case case_1
                                        solve( !KU( h(<'report_data', k, <~mnonce, 'burrito_guest_vm'>, 
                                                       'burrito_report', ~timestamp>)
                                               ) @ #vk.24 )
                                          case SGX_QE_Generate_Quote
                                          solve( !KU( ~mnonce ) @ #vk.28 )
                                            case SEV_PSP_Initialize_Guest
                                            solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', 
                                                           ~tik>)
                                                   ) @ #vk.29 )
                                              case SEV_PSP_Initialize_Guest
                                              solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk.1) ) @ #vk.35 )
                                                case c_sign
                                                solve( !KU( ~amd_rot_ltk.1 ) @ #vk.39 )
                                                  case Compromise_AMD_RoT
                                                  solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                                         (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                                                    case case_1
                                                    solve( !KU( ~timestamp ) @ #vk.39 )
                                                      case Guest_VM_Request_Report
                                                      solve( !AMD_RoT_Ltk( ~amd_rot_ltk ) ▶₀ #j.1 )
                                                        case AMD_RoT_Initialize
                                                        solve( splitEqs(2) )
                                                          case split_case_3
                                                          solve( splitEqs(3) )
                                                            case split_case_4
                                                            solve( !KU( x^(~psp_sn*x.1) ) @ #vk.37 )
                                                              case AMD_RoT_Certify_case_3
                                                              solve( !KU( 'g'^(~go_sn*x) ) @ #vk.38 )
                                                                case TO_Enclave_Deploy_VM_case_3
                                                                SOLVED // trace found
                                                              qed
                                                            qed
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma should_fail_lm_burrito_quote_integrity_7 [heuristic=o "oracle.py"]:
  all-traces
  "∀ ppid d k m #i.
    (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                       h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
     ) @ #i) ⇒
    ((((∃ ts #j.
         (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)) ∨
       (∃ #j. Compromise_Intel_RoT( ) @ #j)) ∨
      (∃ #j. Compromise_SGX_QE( ppid ) @ #j)) ∨
     (∃ #j. Compromise_AMD_RoT( ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ ppid d k m #i.
  (RP_Verify_Quote( <'sgx_quote', 'burrito_enclave_sgx_measurement', ppid, 
                     h(<'report_data', k, <m, 'burrito_guest_vm'>, d>)>
   ) @ #i)
 ∧
  (∀ ts #j.
    (d = <'burrito_report', ts>) ∧ (Guest_VM_Request_Report( k, ts ) @ #j)
   ⇒
    ⊥) ∧
  (∀ #j. (Compromise_Intel_RoT( ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_SGX_QE( ppid ) @ #j) ⇒ ⊥) ∧
  (∀ #j. (Compromise_AMD_RoT( ) @ #j) ⇒ ⊥)"
*/
simplify
solve( (∃ v d.1 k.1 #j.
         (h(<'report_data', k, <m, 'burrito_guest_vm'>, d>) =
          h(<'report_data', k.1, d.1, v>)) ∧
         (TO_Enclave_Generate_Report_For_VM( ~ppid, k.1, d.1, v ) @ #j))  ∥
       (∃ #j. (Compromise_Intel_RoT( ) @ #j))  ∥
       (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
  case case_1
  solve( TO_Enclave_VM_Provisioned( k, ~ppid, <m, 'burrito_guest_vm'>, ~cik
         ) ▶₀ #j )
    case TO_Enclave_Provision_VM
    solve( (∀ #j. (!KU( ~cik ) @ #j) ⇒ ⊥)  ∥
           (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
           (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
      case case_3
      solve( !KU( h(<'report_request', d, ~cik>) ) @ #vk.18 )
        case c_h
        solve( !KU( ~cik ) @ #vk.31 )
          case TO_Enclave_Provision_VM
          solve( ((∀ #j. (!KU( z ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kek', z>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( h(<'sev_kik', z>) ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tek ) @ #j) ⇒ ⊥) ∧
                  (∀ #j. (!KU( ~tik ) @ #j) ⇒ ⊥))  ∥
                 (∃ #j. (Compromise_AMD_RoT( ) @ #j))  ∥
                 (∃ #j. (Compromise_SEV_PSP( k ) @ #j)) )
            case case_3
            solve( !KU( sign(<'sgx_quote', 'burrito_enclave_sgx_measurement', ~ppid, 
                              h(<'report_data', k, <~mnonce, 'burrito_guest_vm'>, d>)>,
                             ~qe_ltk)
                   ) @ #vk.16 )
              case SGX_QE_Generate_Quote_case_1
              solve( (∀ #j. (!KU( ~amd_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                     (∃ #j. (Compromise_AMD_RoT( ) @ #j)) )
                case case_1
                solve( !Intel_RoT_Pk( pk(~intel_rot_ltk) ) ▶₀ #i )
                  case Intel_RoT_Initialize
                  solve( (∀ #j. (!KU( ~intel_rot_ltk ) @ #j) ⇒ ⊥)  ∥
                         (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                    case case_1
                    solve( !KU( ~ppid ) @ #vk.13 )
                      case Intel_RoT_Certify
                      solve( !KU( pk(~qe_ltk) ) @ #vk.19 )
                        case Intel_RoT_Certify
                        solve( !KU( sign(<'sgx_cert', pk(~qe_ltk), ~ppid>, ~intel_rot_ltk)
                               ) @ #vk.20 )
                          case Intel_RoT_Certify
                          solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                 (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j))  ∥
                                 (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                            case case_1
                            solve( (∃ #j. (SGX_QE_Ltk( ~ppid, ~qe_ltk ) @ #j))  ∥
                                   (∃ #j. (Compromise_Intel_RoT( ) @ #j)) )
                              case case_1
                              solve( !KU( h(<'report_data', k, <~mnonce, 'burrito_guest_vm'>, d>)
                                     ) @ #vk.19 )
                                case SGX_QE_Generate_Quote
                                solve( !KU( ~mnonce ) @ #vk.23 )
                                  case Compromise_SEV_PSP
                                  solve( (∀ #j. (!KU( ~mnonce ) @ #j) ⇒ ⊥)  ∥
                                         (∃ #j. (Compromise_SEV_PSP( 'g'^~mnonce ) @ #j)) )
                                    case case_2
                                    solve( !KU( h(<'launch_measurement', ~mnonce, 'burrito_guest_vm', ~tik>)
                                           ) @ #vk.24 )
                                      case c_h
                                      solve( !KU( sign(<'sev_cert', k>, ~amd_rot_ltk) ) @ #vk.32 )
                                        case AMD_RoT_Certify
                                        solve( (∀ #j. (!KU( ~qe_ltk ) @ #j) ⇒ ⊥)  ∥
                                               (∃ #j. (Compromise_SGX_QE( ~ppid ) @ #j)) )
                                          case case_1
                                          solve( !PSP_Ltk( ~cpu_id, ~psp_sn ) ▶₀ #j.1 )
                                            case SEV_PSP_Initialize
                                            solve( !PSP_Pk( ~cpu_id, 'g'^~mnonce ) ▶₁ #j.1 )
                                              case SEV_PSP_Initialize
                                              solve( !KU( ~tek ) @ #vk.35 )
                                                case TO_Enclave_Deploy_VM
                                                solve( !PSP_Ltk( ~cpu_id.1, ~psp_sn ) ▶₀ #j.2 )
                                                  case SEV_PSP_Initialize
                                                  solve( !PSP_Pk( ~cpu_id, 'g'^~mnonce ) ▶₁ #j.2 )
                                                    case SEV_PSP_Initialize
                                                    solve( !KU( ~tik ) @ #vk.37 )
                                                      case TO_Enclave_Deploy_VM
                                                      solve( !KU( 'g'^~mnonce ) @ #vk.35 )
                                                        case AMD_RoT_Certify
                                                        solve( !KU( h(<'sev_kek', 'g'^(~go_sn*~mnonce)>)
                                                               ) @ #vk.38 )
                                                          case c_h
                                                          solve( !KU( 'g'^(~go_sn*~mnonce) ) @ #vk.41 )
                                                            case TO_Enclave_Deploy_VM
                                                            SOLVED // trace found
                                                          qed
                                                        qed
                                                      qed
                                                    qed
                                                  qed
                                                qed
                                              qed
                                            qed
                                          qed
                                        qed
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

/* All well-formedness checks were successful. */

end