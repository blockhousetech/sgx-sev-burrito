/*
 * Burrito
 * Copyright (C) 2023 The Blockhouse Technology Limited (TBTL)
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2eproto;
namespace trustedowner {
class DeployVmReply;
struct DeployVmReplyDefaultTypeInternal;
extern DeployVmReplyDefaultTypeInternal _DeployVmReply_default_instance_;
class DeployVmRequest;
struct DeployVmRequestDefaultTypeInternal;
extern DeployVmRequestDefaultTypeInternal _DeployVmRequest_default_instance_;
class DeployVmRequest_AmdCerts;
struct DeployVmRequest_AmdCertsDefaultTypeInternal;
extern DeployVmRequest_AmdCertsDefaultTypeInternal _DeployVmRequest_AmdCerts_default_instance_;
class DeployVmRequest_MeasurementInfo;
struct DeployVmRequest_MeasurementInfoDefaultTypeInternal;
extern DeployVmRequest_MeasurementInfoDefaultTypeInternal _DeployVmRequest_MeasurementInfo_default_instance_;
class GenerateReportForVmReply;
struct GenerateReportForVmReplyDefaultTypeInternal;
extern GenerateReportForVmReplyDefaultTypeInternal _GenerateReportForVmReply_default_instance_;
class GenerateReportForVmRequest;
struct GenerateReportForVmRequestDefaultTypeInternal;
extern GenerateReportForVmRequestDefaultTypeInternal _GenerateReportForVmRequest_default_instance_;
class ProvisionVmReply;
struct ProvisionVmReplyDefaultTypeInternal;
extern ProvisionVmReplyDefaultTypeInternal _ProvisionVmReply_default_instance_;
class ProvisionVmRequest;
struct ProvisionVmRequestDefaultTypeInternal;
extern ProvisionVmRequestDefaultTypeInternal _ProvisionVmRequest_default_instance_;
}  // namespace trustedowner
PROTOBUF_NAMESPACE_OPEN
template<> ::trustedowner::DeployVmReply* Arena::CreateMaybeMessage<::trustedowner::DeployVmReply>(Arena*);
template<> ::trustedowner::DeployVmRequest* Arena::CreateMaybeMessage<::trustedowner::DeployVmRequest>(Arena*);
template<> ::trustedowner::DeployVmRequest_AmdCerts* Arena::CreateMaybeMessage<::trustedowner::DeployVmRequest_AmdCerts>(Arena*);
template<> ::trustedowner::DeployVmRequest_MeasurementInfo* Arena::CreateMaybeMessage<::trustedowner::DeployVmRequest_MeasurementInfo>(Arena*);
template<> ::trustedowner::GenerateReportForVmReply* Arena::CreateMaybeMessage<::trustedowner::GenerateReportForVmReply>(Arena*);
template<> ::trustedowner::GenerateReportForVmRequest* Arena::CreateMaybeMessage<::trustedowner::GenerateReportForVmRequest>(Arena*);
template<> ::trustedowner::ProvisionVmReply* Arena::CreateMaybeMessage<::trustedowner::ProvisionVmReply>(Arena*);
template<> ::trustedowner::ProvisionVmRequest* Arena::CreateMaybeMessage<::trustedowner::ProvisionVmRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace trustedowner {

// ===================================================================

class DeployVmRequest_AmdCerts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.DeployVmRequest.AmdCerts) */ {
 public:
  inline DeployVmRequest_AmdCerts() : DeployVmRequest_AmdCerts(nullptr) {}
  ~DeployVmRequest_AmdCerts() override;
  explicit constexpr DeployVmRequest_AmdCerts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeployVmRequest_AmdCerts(const DeployVmRequest_AmdCerts& from);
  DeployVmRequest_AmdCerts(DeployVmRequest_AmdCerts&& from) noexcept
    : DeployVmRequest_AmdCerts() {
    *this = ::std::move(from);
  }

  inline DeployVmRequest_AmdCerts& operator=(const DeployVmRequest_AmdCerts& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeployVmRequest_AmdCerts& operator=(DeployVmRequest_AmdCerts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeployVmRequest_AmdCerts& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeployVmRequest_AmdCerts* internal_default_instance() {
    return reinterpret_cast<const DeployVmRequest_AmdCerts*>(
               &_DeployVmRequest_AmdCerts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeployVmRequest_AmdCerts& a, DeployVmRequest_AmdCerts& b) {
    a.Swap(&b);
  }
  inline void Swap(DeployVmRequest_AmdCerts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeployVmRequest_AmdCerts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeployVmRequest_AmdCerts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeployVmRequest_AmdCerts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeployVmRequest_AmdCerts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeployVmRequest_AmdCerts& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeployVmRequest_AmdCerts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.DeployVmRequest.AmdCerts";
  }
  protected:
  explicit DeployVmRequest_AmdCerts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArkFieldNumber = 1,
    kAskFieldNumber = 2,
    kCekFieldNumber = 3,
    kOcaFieldNumber = 4,
    kPekFieldNumber = 5,
    kPdhFieldNumber = 6,
  };
  // bytes ark = 1;
  void clear_ark();
  const std::string& ark() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ark(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ark();
  PROTOBUF_NODISCARD std::string* release_ark();
  void set_allocated_ark(std::string* ark);
  private:
  const std::string& _internal_ark() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ark(const std::string& value);
  std::string* _internal_mutable_ark();
  public:

  // bytes ask = 2;
  void clear_ask();
  const std::string& ask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ask();
  PROTOBUF_NODISCARD std::string* release_ask();
  void set_allocated_ask(std::string* ask);
  private:
  const std::string& _internal_ask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ask(const std::string& value);
  std::string* _internal_mutable_ask();
  public:

  // bytes cek = 3;
  void clear_cek();
  const std::string& cek() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cek(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cek();
  PROTOBUF_NODISCARD std::string* release_cek();
  void set_allocated_cek(std::string* cek);
  private:
  const std::string& _internal_cek() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cek(const std::string& value);
  std::string* _internal_mutable_cek();
  public:

  // bytes oca = 4;
  void clear_oca();
  const std::string& oca() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_oca(ArgT0&& arg0, ArgT... args);
  std::string* mutable_oca();
  PROTOBUF_NODISCARD std::string* release_oca();
  void set_allocated_oca(std::string* oca);
  private:
  const std::string& _internal_oca() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oca(const std::string& value);
  std::string* _internal_mutable_oca();
  public:

  // bytes pek = 5;
  void clear_pek();
  const std::string& pek() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pek(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pek();
  PROTOBUF_NODISCARD std::string* release_pek();
  void set_allocated_pek(std::string* pek);
  private:
  const std::string& _internal_pek() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pek(const std::string& value);
  std::string* _internal_mutable_pek();
  public:

  // bytes pdh = 6;
  void clear_pdh();
  const std::string& pdh() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pdh(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pdh();
  PROTOBUF_NODISCARD std::string* release_pdh();
  void set_allocated_pdh(std::string* pdh);
  private:
  const std::string& _internal_pdh() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pdh(const std::string& value);
  std::string* _internal_mutable_pdh();
  public:

  // @@protoc_insertion_point(class_scope:trustedowner.DeployVmRequest.AmdCerts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ark_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ask_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cek_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr oca_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pek_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pdh_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class DeployVmRequest_MeasurementInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.DeployVmRequest.MeasurementInfo) */ {
 public:
  inline DeployVmRequest_MeasurementInfo() : DeployVmRequest_MeasurementInfo(nullptr) {}
  ~DeployVmRequest_MeasurementInfo() override;
  explicit constexpr DeployVmRequest_MeasurementInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeployVmRequest_MeasurementInfo(const DeployVmRequest_MeasurementInfo& from);
  DeployVmRequest_MeasurementInfo(DeployVmRequest_MeasurementInfo&& from) noexcept
    : DeployVmRequest_MeasurementInfo() {
    *this = ::std::move(from);
  }

  inline DeployVmRequest_MeasurementInfo& operator=(const DeployVmRequest_MeasurementInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeployVmRequest_MeasurementInfo& operator=(DeployVmRequest_MeasurementInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeployVmRequest_MeasurementInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeployVmRequest_MeasurementInfo* internal_default_instance() {
    return reinterpret_cast<const DeployVmRequest_MeasurementInfo*>(
               &_DeployVmRequest_MeasurementInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DeployVmRequest_MeasurementInfo& a, DeployVmRequest_MeasurementInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeployVmRequest_MeasurementInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeployVmRequest_MeasurementInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeployVmRequest_MeasurementInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeployVmRequest_MeasurementInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeployVmRequest_MeasurementInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeployVmRequest_MeasurementInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeployVmRequest_MeasurementInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.DeployVmRequest.MeasurementInfo";
  }
  protected:
  explicit DeployVmRequest_MeasurementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDigestFieldNumber = 5,
    kApiMajorFieldNumber = 1,
    kApiMinorFieldNumber = 2,
    kBuildIdFieldNumber = 3,
    kPolicyFieldNumber = 4,
  };
  // bytes digest = 5;
  void clear_digest();
  const std::string& digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_digest();
  PROTOBUF_NODISCARD std::string* release_digest();
  void set_allocated_digest(std::string* digest);
  private:
  const std::string& _internal_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digest(const std::string& value);
  std::string* _internal_mutable_digest();
  public:

  // uint32 api_major = 1;
  void clear_api_major();
  uint32_t api_major() const;
  void set_api_major(uint32_t value);
  private:
  uint32_t _internal_api_major() const;
  void _internal_set_api_major(uint32_t value);
  public:

  // uint32 api_minor = 2;
  void clear_api_minor();
  uint32_t api_minor() const;
  void set_api_minor(uint32_t value);
  private:
  uint32_t _internal_api_minor() const;
  void _internal_set_api_minor(uint32_t value);
  public:

  // uint32 build_id = 3;
  void clear_build_id();
  uint32_t build_id() const;
  void set_build_id(uint32_t value);
  private:
  uint32_t _internal_build_id() const;
  void _internal_set_build_id(uint32_t value);
  public:

  // uint32 policy = 4;
  void clear_policy();
  uint32_t policy() const;
  void set_policy(uint32_t value);
  private:
  uint32_t _internal_policy() const;
  void _internal_set_policy(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:trustedowner.DeployVmRequest.MeasurementInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digest_;
  uint32_t api_major_;
  uint32_t api_minor_;
  uint32_t build_id_;
  uint32_t policy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class DeployVmRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.DeployVmRequest) */ {
 public:
  inline DeployVmRequest() : DeployVmRequest(nullptr) {}
  ~DeployVmRequest() override;
  explicit constexpr DeployVmRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeployVmRequest(const DeployVmRequest& from);
  DeployVmRequest(DeployVmRequest&& from) noexcept
    : DeployVmRequest() {
    *this = ::std::move(from);
  }

  inline DeployVmRequest& operator=(const DeployVmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeployVmRequest& operator=(DeployVmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeployVmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeployVmRequest* internal_default_instance() {
    return reinterpret_cast<const DeployVmRequest*>(
               &_DeployVmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DeployVmRequest& a, DeployVmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeployVmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeployVmRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeployVmRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeployVmRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeployVmRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeployVmRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeployVmRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.DeployVmRequest";
  }
  protected:
  explicit DeployVmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeployVmRequest_AmdCerts AmdCerts;
  typedef DeployVmRequest_MeasurementInfo MeasurementInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kCertsFieldNumber = 1,
    kInfoFieldNumber = 2,
  };
  // .trustedowner.DeployVmRequest.AmdCerts certs = 1;
  bool has_certs() const;
  private:
  bool _internal_has_certs() const;
  public:
  void clear_certs();
  const ::trustedowner::DeployVmRequest_AmdCerts& certs() const;
  PROTOBUF_NODISCARD ::trustedowner::DeployVmRequest_AmdCerts* release_certs();
  ::trustedowner::DeployVmRequest_AmdCerts* mutable_certs();
  void set_allocated_certs(::trustedowner::DeployVmRequest_AmdCerts* certs);
  private:
  const ::trustedowner::DeployVmRequest_AmdCerts& _internal_certs() const;
  ::trustedowner::DeployVmRequest_AmdCerts* _internal_mutable_certs();
  public:
  void unsafe_arena_set_allocated_certs(
      ::trustedowner::DeployVmRequest_AmdCerts* certs);
  ::trustedowner::DeployVmRequest_AmdCerts* unsafe_arena_release_certs();

  // .trustedowner.DeployVmRequest.MeasurementInfo info = 2;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::trustedowner::DeployVmRequest_MeasurementInfo& info() const;
  PROTOBUF_NODISCARD ::trustedowner::DeployVmRequest_MeasurementInfo* release_info();
  ::trustedowner::DeployVmRequest_MeasurementInfo* mutable_info();
  void set_allocated_info(::trustedowner::DeployVmRequest_MeasurementInfo* info);
  private:
  const ::trustedowner::DeployVmRequest_MeasurementInfo& _internal_info() const;
  ::trustedowner::DeployVmRequest_MeasurementInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::trustedowner::DeployVmRequest_MeasurementInfo* info);
  ::trustedowner::DeployVmRequest_MeasurementInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:trustedowner.DeployVmRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trustedowner::DeployVmRequest_AmdCerts* certs_;
  ::trustedowner::DeployVmRequest_MeasurementInfo* info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class DeployVmReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.DeployVmReply) */ {
 public:
  inline DeployVmReply() : DeployVmReply(nullptr) {}
  ~DeployVmReply() override;
  explicit constexpr DeployVmReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeployVmReply(const DeployVmReply& from);
  DeployVmReply(DeployVmReply&& from) noexcept
    : DeployVmReply() {
    *this = ::std::move(from);
  }

  inline DeployVmReply& operator=(const DeployVmReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeployVmReply& operator=(DeployVmReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeployVmReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeployVmReply* internal_default_instance() {
    return reinterpret_cast<const DeployVmReply*>(
               &_DeployVmReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DeployVmReply& a, DeployVmReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeployVmReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeployVmReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeployVmReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeployVmReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeployVmReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeployVmReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeployVmReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.DeployVmReply";
  }
  protected:
  explicit DeployVmReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionBufferFieldNumber = 1,
    kGodhCertFieldNumber = 2,
  };
  // bytes session_buffer = 1;
  void clear_session_buffer();
  const std::string& session_buffer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_buffer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_buffer();
  PROTOBUF_NODISCARD std::string* release_session_buffer();
  void set_allocated_session_buffer(std::string* session_buffer);
  private:
  const std::string& _internal_session_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_buffer(const std::string& value);
  std::string* _internal_mutable_session_buffer();
  public:

  // bytes godh_cert = 2;
  void clear_godh_cert();
  const std::string& godh_cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_godh_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_godh_cert();
  PROTOBUF_NODISCARD std::string* release_godh_cert();
  void set_allocated_godh_cert(std::string* godh_cert);
  private:
  const std::string& _internal_godh_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_godh_cert(const std::string& value);
  std::string* _internal_mutable_godh_cert();
  public:

  // @@protoc_insertion_point(class_scope:trustedowner.DeployVmReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_buffer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr godh_cert_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ProvisionVmRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.ProvisionVmRequest) */ {
 public:
  inline ProvisionVmRequest() : ProvisionVmRequest(nullptr) {}
  ~ProvisionVmRequest() override;
  explicit constexpr ProvisionVmRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProvisionVmRequest(const ProvisionVmRequest& from);
  ProvisionVmRequest(ProvisionVmRequest&& from) noexcept
    : ProvisionVmRequest() {
    *this = ::std::move(from);
  }

  inline ProvisionVmRequest& operator=(const ProvisionVmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProvisionVmRequest& operator=(ProvisionVmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProvisionVmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProvisionVmRequest* internal_default_instance() {
    return reinterpret_cast<const ProvisionVmRequest*>(
               &_ProvisionVmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ProvisionVmRequest& a, ProvisionVmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProvisionVmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProvisionVmRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProvisionVmRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProvisionVmRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProvisionVmRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProvisionVmRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProvisionVmRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.ProvisionVmRequest";
  }
  protected:
  explicit ProvisionVmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeasurementFieldNumber = 1,
    kMnonceFieldNumber = 2,
  };
  // bytes measurement = 1;
  void clear_measurement();
  const std::string& measurement() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_measurement(ArgT0&& arg0, ArgT... args);
  std::string* mutable_measurement();
  PROTOBUF_NODISCARD std::string* release_measurement();
  void set_allocated_measurement(std::string* measurement);
  private:
  const std::string& _internal_measurement() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_measurement(const std::string& value);
  std::string* _internal_mutable_measurement();
  public:

  // bytes mnonce = 2;
  void clear_mnonce();
  const std::string& mnonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mnonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mnonce();
  PROTOBUF_NODISCARD std::string* release_mnonce();
  void set_allocated_mnonce(std::string* mnonce);
  private:
  const std::string& _internal_mnonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mnonce(const std::string& value);
  std::string* _internal_mutable_mnonce();
  public:

  // @@protoc_insertion_point(class_scope:trustedowner.ProvisionVmRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr measurement_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mnonce_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ProvisionVmReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.ProvisionVmReply) */ {
 public:
  inline ProvisionVmReply() : ProvisionVmReply(nullptr) {}
  ~ProvisionVmReply() override;
  explicit constexpr ProvisionVmReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProvisionVmReply(const ProvisionVmReply& from);
  ProvisionVmReply(ProvisionVmReply&& from) noexcept
    : ProvisionVmReply() {
    *this = ::std::move(from);
  }

  inline ProvisionVmReply& operator=(const ProvisionVmReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProvisionVmReply& operator=(ProvisionVmReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProvisionVmReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProvisionVmReply* internal_default_instance() {
    return reinterpret_cast<const ProvisionVmReply*>(
               &_ProvisionVmReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProvisionVmReply& a, ProvisionVmReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ProvisionVmReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProvisionVmReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProvisionVmReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProvisionVmReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProvisionVmReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProvisionVmReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProvisionVmReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.ProvisionVmReply";
  }
  protected:
  explicit ProvisionVmReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretHeaderFieldNumber = 1,
    kSecretBlobFieldNumber = 2,
  };
  // bytes secret_header = 1;
  void clear_secret_header();
  const std::string& secret_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_header();
  PROTOBUF_NODISCARD std::string* release_secret_header();
  void set_allocated_secret_header(std::string* secret_header);
  private:
  const std::string& _internal_secret_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_header(const std::string& value);
  std::string* _internal_mutable_secret_header();
  public:

  // bytes secret_blob = 2;
  void clear_secret_blob();
  const std::string& secret_blob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret_blob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret_blob();
  PROTOBUF_NODISCARD std::string* release_secret_blob();
  void set_allocated_secret_blob(std::string* secret_blob);
  private:
  const std::string& _internal_secret_blob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret_blob(const std::string& value);
  std::string* _internal_mutable_secret_blob();
  public:

  // @@protoc_insertion_point(class_scope:trustedowner.ProvisionVmReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_header_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_blob_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class GenerateReportForVmRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.GenerateReportForVmRequest) */ {
 public:
  inline GenerateReportForVmRequest() : GenerateReportForVmRequest(nullptr) {}
  ~GenerateReportForVmRequest() override;
  explicit constexpr GenerateReportForVmRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateReportForVmRequest(const GenerateReportForVmRequest& from);
  GenerateReportForVmRequest(GenerateReportForVmRequest&& from) noexcept
    : GenerateReportForVmRequest() {
    *this = ::std::move(from);
  }

  inline GenerateReportForVmRequest& operator=(const GenerateReportForVmRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateReportForVmRequest& operator=(GenerateReportForVmRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateReportForVmRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateReportForVmRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateReportForVmRequest*>(
               &_GenerateReportForVmRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GenerateReportForVmRequest& a, GenerateReportForVmRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateReportForVmRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateReportForVmRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateReportForVmRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateReportForVmRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateReportForVmRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateReportForVmRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateReportForVmRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.GenerateReportForVmRequest";
  }
  protected:
  explicit GenerateReportForVmRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVmDataFieldNumber = 1,
    kVmDataHmacFieldNumber = 2,
  };
  // bytes vm_data = 1;
  void clear_vm_data();
  const std::string& vm_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vm_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vm_data();
  PROTOBUF_NODISCARD std::string* release_vm_data();
  void set_allocated_vm_data(std::string* vm_data);
  private:
  const std::string& _internal_vm_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vm_data(const std::string& value);
  std::string* _internal_mutable_vm_data();
  public:

  // bytes vm_data_hmac = 2;
  void clear_vm_data_hmac();
  const std::string& vm_data_hmac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vm_data_hmac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vm_data_hmac();
  PROTOBUF_NODISCARD std::string* release_vm_data_hmac();
  void set_allocated_vm_data_hmac(std::string* vm_data_hmac);
  private:
  const std::string& _internal_vm_data_hmac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vm_data_hmac(const std::string& value);
  std::string* _internal_mutable_vm_data_hmac();
  public:

  // @@protoc_insertion_point(class_scope:trustedowner.GenerateReportForVmRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vm_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vm_data_hmac_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class GenerateReportForVmReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trustedowner.GenerateReportForVmReply) */ {
 public:
  inline GenerateReportForVmReply() : GenerateReportForVmReply(nullptr) {}
  ~GenerateReportForVmReply() override;
  explicit constexpr GenerateReportForVmReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateReportForVmReply(const GenerateReportForVmReply& from);
  GenerateReportForVmReply(GenerateReportForVmReply&& from) noexcept
    : GenerateReportForVmReply() {
    *this = ::std::move(from);
  }

  inline GenerateReportForVmReply& operator=(const GenerateReportForVmReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateReportForVmReply& operator=(GenerateReportForVmReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateReportForVmReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateReportForVmReply* internal_default_instance() {
    return reinterpret_cast<const GenerateReportForVmReply*>(
               &_GenerateReportForVmReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GenerateReportForVmReply& a, GenerateReportForVmReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateReportForVmReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateReportForVmReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenerateReportForVmReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GenerateReportForVmReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateReportForVmReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateReportForVmReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateReportForVmReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trustedowner.GenerateReportForVmReply";
  }
  protected:
  explicit GenerateReportForVmReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuoteFieldNumber = 1,
  };
  // bytes quote = 1;
  void clear_quote();
  const std::string& quote() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quote(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quote();
  PROTOBUF_NODISCARD std::string* release_quote();
  void set_allocated_quote(std::string* quote);
  private:
  const std::string& _internal_quote() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quote(const std::string& value);
  std::string* _internal_mutable_quote();
  public:

  // @@protoc_insertion_point(class_scope:trustedowner.GenerateReportForVmReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quote_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_server_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeployVmRequest_AmdCerts

// bytes ark = 1;
inline void DeployVmRequest_AmdCerts::clear_ark() {
  ark_.ClearToEmpty();
}
inline const std::string& DeployVmRequest_AmdCerts::ark() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.AmdCerts.ark)
  return _internal_ark();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmRequest_AmdCerts::set_ark(ArgT0&& arg0, ArgT... args) {
 
 ark_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.AmdCerts.ark)
}
inline std::string* DeployVmRequest_AmdCerts::mutable_ark() {
  std::string* _s = _internal_mutable_ark();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.AmdCerts.ark)
  return _s;
}
inline const std::string& DeployVmRequest_AmdCerts::_internal_ark() const {
  return ark_.Get();
}
inline void DeployVmRequest_AmdCerts::_internal_set_ark(const std::string& value) {
  
  ark_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::_internal_mutable_ark() {
  
  return ark_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::release_ark() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.AmdCerts.ark)
  return ark_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmRequest_AmdCerts::set_allocated_ark(std::string* ark) {
  if (ark != nullptr) {
    
  } else {
    
  }
  ark_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ark,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ark_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ark_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.AmdCerts.ark)
}

// bytes ask = 2;
inline void DeployVmRequest_AmdCerts::clear_ask() {
  ask_.ClearToEmpty();
}
inline const std::string& DeployVmRequest_AmdCerts::ask() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.AmdCerts.ask)
  return _internal_ask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmRequest_AmdCerts::set_ask(ArgT0&& arg0, ArgT... args) {
 
 ask_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.AmdCerts.ask)
}
inline std::string* DeployVmRequest_AmdCerts::mutable_ask() {
  std::string* _s = _internal_mutable_ask();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.AmdCerts.ask)
  return _s;
}
inline const std::string& DeployVmRequest_AmdCerts::_internal_ask() const {
  return ask_.Get();
}
inline void DeployVmRequest_AmdCerts::_internal_set_ask(const std::string& value) {
  
  ask_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::_internal_mutable_ask() {
  
  return ask_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::release_ask() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.AmdCerts.ask)
  return ask_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmRequest_AmdCerts::set_allocated_ask(std::string* ask) {
  if (ask != nullptr) {
    
  } else {
    
  }
  ask_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ask,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ask_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ask_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.AmdCerts.ask)
}

// bytes cek = 3;
inline void DeployVmRequest_AmdCerts::clear_cek() {
  cek_.ClearToEmpty();
}
inline const std::string& DeployVmRequest_AmdCerts::cek() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.AmdCerts.cek)
  return _internal_cek();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmRequest_AmdCerts::set_cek(ArgT0&& arg0, ArgT... args) {
 
 cek_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.AmdCerts.cek)
}
inline std::string* DeployVmRequest_AmdCerts::mutable_cek() {
  std::string* _s = _internal_mutable_cek();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.AmdCerts.cek)
  return _s;
}
inline const std::string& DeployVmRequest_AmdCerts::_internal_cek() const {
  return cek_.Get();
}
inline void DeployVmRequest_AmdCerts::_internal_set_cek(const std::string& value) {
  
  cek_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::_internal_mutable_cek() {
  
  return cek_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::release_cek() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.AmdCerts.cek)
  return cek_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmRequest_AmdCerts::set_allocated_cek(std::string* cek) {
  if (cek != nullptr) {
    
  } else {
    
  }
  cek_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cek,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cek_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cek_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.AmdCerts.cek)
}

// bytes oca = 4;
inline void DeployVmRequest_AmdCerts::clear_oca() {
  oca_.ClearToEmpty();
}
inline const std::string& DeployVmRequest_AmdCerts::oca() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.AmdCerts.oca)
  return _internal_oca();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmRequest_AmdCerts::set_oca(ArgT0&& arg0, ArgT... args) {
 
 oca_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.AmdCerts.oca)
}
inline std::string* DeployVmRequest_AmdCerts::mutable_oca() {
  std::string* _s = _internal_mutable_oca();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.AmdCerts.oca)
  return _s;
}
inline const std::string& DeployVmRequest_AmdCerts::_internal_oca() const {
  return oca_.Get();
}
inline void DeployVmRequest_AmdCerts::_internal_set_oca(const std::string& value) {
  
  oca_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::_internal_mutable_oca() {
  
  return oca_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::release_oca() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.AmdCerts.oca)
  return oca_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmRequest_AmdCerts::set_allocated_oca(std::string* oca) {
  if (oca != nullptr) {
    
  } else {
    
  }
  oca_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), oca,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (oca_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    oca_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.AmdCerts.oca)
}

// bytes pek = 5;
inline void DeployVmRequest_AmdCerts::clear_pek() {
  pek_.ClearToEmpty();
}
inline const std::string& DeployVmRequest_AmdCerts::pek() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.AmdCerts.pek)
  return _internal_pek();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmRequest_AmdCerts::set_pek(ArgT0&& arg0, ArgT... args) {
 
 pek_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.AmdCerts.pek)
}
inline std::string* DeployVmRequest_AmdCerts::mutable_pek() {
  std::string* _s = _internal_mutable_pek();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.AmdCerts.pek)
  return _s;
}
inline const std::string& DeployVmRequest_AmdCerts::_internal_pek() const {
  return pek_.Get();
}
inline void DeployVmRequest_AmdCerts::_internal_set_pek(const std::string& value) {
  
  pek_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::_internal_mutable_pek() {
  
  return pek_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::release_pek() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.AmdCerts.pek)
  return pek_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmRequest_AmdCerts::set_allocated_pek(std::string* pek) {
  if (pek != nullptr) {
    
  } else {
    
  }
  pek_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pek,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pek_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pek_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.AmdCerts.pek)
}

// bytes pdh = 6;
inline void DeployVmRequest_AmdCerts::clear_pdh() {
  pdh_.ClearToEmpty();
}
inline const std::string& DeployVmRequest_AmdCerts::pdh() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.AmdCerts.pdh)
  return _internal_pdh();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmRequest_AmdCerts::set_pdh(ArgT0&& arg0, ArgT... args) {
 
 pdh_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.AmdCerts.pdh)
}
inline std::string* DeployVmRequest_AmdCerts::mutable_pdh() {
  std::string* _s = _internal_mutable_pdh();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.AmdCerts.pdh)
  return _s;
}
inline const std::string& DeployVmRequest_AmdCerts::_internal_pdh() const {
  return pdh_.Get();
}
inline void DeployVmRequest_AmdCerts::_internal_set_pdh(const std::string& value) {
  
  pdh_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::_internal_mutable_pdh() {
  
  return pdh_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_AmdCerts::release_pdh() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.AmdCerts.pdh)
  return pdh_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmRequest_AmdCerts::set_allocated_pdh(std::string* pdh) {
  if (pdh != nullptr) {
    
  } else {
    
  }
  pdh_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pdh,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pdh_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pdh_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.AmdCerts.pdh)
}

// -------------------------------------------------------------------

// DeployVmRequest_MeasurementInfo

// uint32 api_major = 1;
inline void DeployVmRequest_MeasurementInfo::clear_api_major() {
  api_major_ = 0u;
}
inline uint32_t DeployVmRequest_MeasurementInfo::_internal_api_major() const {
  return api_major_;
}
inline uint32_t DeployVmRequest_MeasurementInfo::api_major() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.MeasurementInfo.api_major)
  return _internal_api_major();
}
inline void DeployVmRequest_MeasurementInfo::_internal_set_api_major(uint32_t value) {
  
  api_major_ = value;
}
inline void DeployVmRequest_MeasurementInfo::set_api_major(uint32_t value) {
  _internal_set_api_major(value);
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.MeasurementInfo.api_major)
}

// uint32 api_minor = 2;
inline void DeployVmRequest_MeasurementInfo::clear_api_minor() {
  api_minor_ = 0u;
}
inline uint32_t DeployVmRequest_MeasurementInfo::_internal_api_minor() const {
  return api_minor_;
}
inline uint32_t DeployVmRequest_MeasurementInfo::api_minor() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.MeasurementInfo.api_minor)
  return _internal_api_minor();
}
inline void DeployVmRequest_MeasurementInfo::_internal_set_api_minor(uint32_t value) {
  
  api_minor_ = value;
}
inline void DeployVmRequest_MeasurementInfo::set_api_minor(uint32_t value) {
  _internal_set_api_minor(value);
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.MeasurementInfo.api_minor)
}

// uint32 build_id = 3;
inline void DeployVmRequest_MeasurementInfo::clear_build_id() {
  build_id_ = 0u;
}
inline uint32_t DeployVmRequest_MeasurementInfo::_internal_build_id() const {
  return build_id_;
}
inline uint32_t DeployVmRequest_MeasurementInfo::build_id() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.MeasurementInfo.build_id)
  return _internal_build_id();
}
inline void DeployVmRequest_MeasurementInfo::_internal_set_build_id(uint32_t value) {
  
  build_id_ = value;
}
inline void DeployVmRequest_MeasurementInfo::set_build_id(uint32_t value) {
  _internal_set_build_id(value);
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.MeasurementInfo.build_id)
}

// uint32 policy = 4;
inline void DeployVmRequest_MeasurementInfo::clear_policy() {
  policy_ = 0u;
}
inline uint32_t DeployVmRequest_MeasurementInfo::_internal_policy() const {
  return policy_;
}
inline uint32_t DeployVmRequest_MeasurementInfo::policy() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.MeasurementInfo.policy)
  return _internal_policy();
}
inline void DeployVmRequest_MeasurementInfo::_internal_set_policy(uint32_t value) {
  
  policy_ = value;
}
inline void DeployVmRequest_MeasurementInfo::set_policy(uint32_t value) {
  _internal_set_policy(value);
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.MeasurementInfo.policy)
}

// bytes digest = 5;
inline void DeployVmRequest_MeasurementInfo::clear_digest() {
  digest_.ClearToEmpty();
}
inline const std::string& DeployVmRequest_MeasurementInfo::digest() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.MeasurementInfo.digest)
  return _internal_digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmRequest_MeasurementInfo::set_digest(ArgT0&& arg0, ArgT... args) {
 
 digest_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmRequest.MeasurementInfo.digest)
}
inline std::string* DeployVmRequest_MeasurementInfo::mutable_digest() {
  std::string* _s = _internal_mutable_digest();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.MeasurementInfo.digest)
  return _s;
}
inline const std::string& DeployVmRequest_MeasurementInfo::_internal_digest() const {
  return digest_.Get();
}
inline void DeployVmRequest_MeasurementInfo::_internal_set_digest(const std::string& value) {
  
  digest_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_MeasurementInfo::_internal_mutable_digest() {
  
  return digest_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmRequest_MeasurementInfo::release_digest() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.MeasurementInfo.digest)
  return digest_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmRequest_MeasurementInfo::set_allocated_digest(std::string* digest) {
  if (digest != nullptr) {
    
  } else {
    
  }
  digest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digest,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (digest_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    digest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.MeasurementInfo.digest)
}

// -------------------------------------------------------------------

// DeployVmRequest

// .trustedowner.DeployVmRequest.AmdCerts certs = 1;
inline bool DeployVmRequest::_internal_has_certs() const {
  return this != internal_default_instance() && certs_ != nullptr;
}
inline bool DeployVmRequest::has_certs() const {
  return _internal_has_certs();
}
inline void DeployVmRequest::clear_certs() {
  if (GetArenaForAllocation() == nullptr && certs_ != nullptr) {
    delete certs_;
  }
  certs_ = nullptr;
}
inline const ::trustedowner::DeployVmRequest_AmdCerts& DeployVmRequest::_internal_certs() const {
  const ::trustedowner::DeployVmRequest_AmdCerts* p = certs_;
  return p != nullptr ? *p : reinterpret_cast<const ::trustedowner::DeployVmRequest_AmdCerts&>(
      ::trustedowner::_DeployVmRequest_AmdCerts_default_instance_);
}
inline const ::trustedowner::DeployVmRequest_AmdCerts& DeployVmRequest::certs() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.certs)
  return _internal_certs();
}
inline void DeployVmRequest::unsafe_arena_set_allocated_certs(
    ::trustedowner::DeployVmRequest_AmdCerts* certs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(certs_);
  }
  certs_ = certs;
  if (certs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trustedowner.DeployVmRequest.certs)
}
inline ::trustedowner::DeployVmRequest_AmdCerts* DeployVmRequest::release_certs() {
  
  ::trustedowner::DeployVmRequest_AmdCerts* temp = certs_;
  certs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trustedowner::DeployVmRequest_AmdCerts* DeployVmRequest::unsafe_arena_release_certs() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.certs)
  
  ::trustedowner::DeployVmRequest_AmdCerts* temp = certs_;
  certs_ = nullptr;
  return temp;
}
inline ::trustedowner::DeployVmRequest_AmdCerts* DeployVmRequest::_internal_mutable_certs() {
  
  if (certs_ == nullptr) {
    auto* p = CreateMaybeMessage<::trustedowner::DeployVmRequest_AmdCerts>(GetArenaForAllocation());
    certs_ = p;
  }
  return certs_;
}
inline ::trustedowner::DeployVmRequest_AmdCerts* DeployVmRequest::mutable_certs() {
  ::trustedowner::DeployVmRequest_AmdCerts* _msg = _internal_mutable_certs();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.certs)
  return _msg;
}
inline void DeployVmRequest::set_allocated_certs(::trustedowner::DeployVmRequest_AmdCerts* certs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete certs_;
  }
  if (certs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::trustedowner::DeployVmRequest_AmdCerts>::GetOwningArena(certs);
    if (message_arena != submessage_arena) {
      certs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, certs, submessage_arena);
    }
    
  } else {
    
  }
  certs_ = certs;
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.certs)
}

// .trustedowner.DeployVmRequest.MeasurementInfo info = 2;
inline bool DeployVmRequest::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool DeployVmRequest::has_info() const {
  return _internal_has_info();
}
inline void DeployVmRequest::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::trustedowner::DeployVmRequest_MeasurementInfo& DeployVmRequest::_internal_info() const {
  const ::trustedowner::DeployVmRequest_MeasurementInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::trustedowner::DeployVmRequest_MeasurementInfo&>(
      ::trustedowner::_DeployVmRequest_MeasurementInfo_default_instance_);
}
inline const ::trustedowner::DeployVmRequest_MeasurementInfo& DeployVmRequest::info() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmRequest.info)
  return _internal_info();
}
inline void DeployVmRequest::unsafe_arena_set_allocated_info(
    ::trustedowner::DeployVmRequest_MeasurementInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trustedowner.DeployVmRequest.info)
}
inline ::trustedowner::DeployVmRequest_MeasurementInfo* DeployVmRequest::release_info() {
  
  ::trustedowner::DeployVmRequest_MeasurementInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trustedowner::DeployVmRequest_MeasurementInfo* DeployVmRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmRequest.info)
  
  ::trustedowner::DeployVmRequest_MeasurementInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::trustedowner::DeployVmRequest_MeasurementInfo* DeployVmRequest::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::trustedowner::DeployVmRequest_MeasurementInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::trustedowner::DeployVmRequest_MeasurementInfo* DeployVmRequest::mutable_info() {
  ::trustedowner::DeployVmRequest_MeasurementInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmRequest.info)
  return _msg;
}
inline void DeployVmRequest::set_allocated_info(::trustedowner::DeployVmRequest_MeasurementInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::trustedowner::DeployVmRequest_MeasurementInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmRequest.info)
}

// -------------------------------------------------------------------

// DeployVmReply

// bytes session_buffer = 1;
inline void DeployVmReply::clear_session_buffer() {
  session_buffer_.ClearToEmpty();
}
inline const std::string& DeployVmReply::session_buffer() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmReply.session_buffer)
  return _internal_session_buffer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmReply::set_session_buffer(ArgT0&& arg0, ArgT... args) {
 
 session_buffer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmReply.session_buffer)
}
inline std::string* DeployVmReply::mutable_session_buffer() {
  std::string* _s = _internal_mutable_session_buffer();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmReply.session_buffer)
  return _s;
}
inline const std::string& DeployVmReply::_internal_session_buffer() const {
  return session_buffer_.Get();
}
inline void DeployVmReply::_internal_set_session_buffer(const std::string& value) {
  
  session_buffer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmReply::_internal_mutable_session_buffer() {
  
  return session_buffer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmReply::release_session_buffer() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmReply.session_buffer)
  return session_buffer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmReply::set_allocated_session_buffer(std::string* session_buffer) {
  if (session_buffer != nullptr) {
    
  } else {
    
  }
  session_buffer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), session_buffer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_buffer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    session_buffer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmReply.session_buffer)
}

// bytes godh_cert = 2;
inline void DeployVmReply::clear_godh_cert() {
  godh_cert_.ClearToEmpty();
}
inline const std::string& DeployVmReply::godh_cert() const {
  // @@protoc_insertion_point(field_get:trustedowner.DeployVmReply.godh_cert)
  return _internal_godh_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeployVmReply::set_godh_cert(ArgT0&& arg0, ArgT... args) {
 
 godh_cert_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.DeployVmReply.godh_cert)
}
inline std::string* DeployVmReply::mutable_godh_cert() {
  std::string* _s = _internal_mutable_godh_cert();
  // @@protoc_insertion_point(field_mutable:trustedowner.DeployVmReply.godh_cert)
  return _s;
}
inline const std::string& DeployVmReply::_internal_godh_cert() const {
  return godh_cert_.Get();
}
inline void DeployVmReply::_internal_set_godh_cert(const std::string& value) {
  
  godh_cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeployVmReply::_internal_mutable_godh_cert() {
  
  return godh_cert_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeployVmReply::release_godh_cert() {
  // @@protoc_insertion_point(field_release:trustedowner.DeployVmReply.godh_cert)
  return godh_cert_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeployVmReply::set_allocated_godh_cert(std::string* godh_cert) {
  if (godh_cert != nullptr) {
    
  } else {
    
  }
  godh_cert_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), godh_cert,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (godh_cert_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    godh_cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.DeployVmReply.godh_cert)
}

// -------------------------------------------------------------------

// ProvisionVmRequest

// bytes measurement = 1;
inline void ProvisionVmRequest::clear_measurement() {
  measurement_.ClearToEmpty();
}
inline const std::string& ProvisionVmRequest::measurement() const {
  // @@protoc_insertion_point(field_get:trustedowner.ProvisionVmRequest.measurement)
  return _internal_measurement();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProvisionVmRequest::set_measurement(ArgT0&& arg0, ArgT... args) {
 
 measurement_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.ProvisionVmRequest.measurement)
}
inline std::string* ProvisionVmRequest::mutable_measurement() {
  std::string* _s = _internal_mutable_measurement();
  // @@protoc_insertion_point(field_mutable:trustedowner.ProvisionVmRequest.measurement)
  return _s;
}
inline const std::string& ProvisionVmRequest::_internal_measurement() const {
  return measurement_.Get();
}
inline void ProvisionVmRequest::_internal_set_measurement(const std::string& value) {
  
  measurement_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProvisionVmRequest::_internal_mutable_measurement() {
  
  return measurement_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProvisionVmRequest::release_measurement() {
  // @@protoc_insertion_point(field_release:trustedowner.ProvisionVmRequest.measurement)
  return measurement_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProvisionVmRequest::set_allocated_measurement(std::string* measurement) {
  if (measurement != nullptr) {
    
  } else {
    
  }
  measurement_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), measurement,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (measurement_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    measurement_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.ProvisionVmRequest.measurement)
}

// bytes mnonce = 2;
inline void ProvisionVmRequest::clear_mnonce() {
  mnonce_.ClearToEmpty();
}
inline const std::string& ProvisionVmRequest::mnonce() const {
  // @@protoc_insertion_point(field_get:trustedowner.ProvisionVmRequest.mnonce)
  return _internal_mnonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProvisionVmRequest::set_mnonce(ArgT0&& arg0, ArgT... args) {
 
 mnonce_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.ProvisionVmRequest.mnonce)
}
inline std::string* ProvisionVmRequest::mutable_mnonce() {
  std::string* _s = _internal_mutable_mnonce();
  // @@protoc_insertion_point(field_mutable:trustedowner.ProvisionVmRequest.mnonce)
  return _s;
}
inline const std::string& ProvisionVmRequest::_internal_mnonce() const {
  return mnonce_.Get();
}
inline void ProvisionVmRequest::_internal_set_mnonce(const std::string& value) {
  
  mnonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProvisionVmRequest::_internal_mutable_mnonce() {
  
  return mnonce_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProvisionVmRequest::release_mnonce() {
  // @@protoc_insertion_point(field_release:trustedowner.ProvisionVmRequest.mnonce)
  return mnonce_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProvisionVmRequest::set_allocated_mnonce(std::string* mnonce) {
  if (mnonce != nullptr) {
    
  } else {
    
  }
  mnonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mnonce,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mnonce_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mnonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.ProvisionVmRequest.mnonce)
}

// -------------------------------------------------------------------

// ProvisionVmReply

// bytes secret_header = 1;
inline void ProvisionVmReply::clear_secret_header() {
  secret_header_.ClearToEmpty();
}
inline const std::string& ProvisionVmReply::secret_header() const {
  // @@protoc_insertion_point(field_get:trustedowner.ProvisionVmReply.secret_header)
  return _internal_secret_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProvisionVmReply::set_secret_header(ArgT0&& arg0, ArgT... args) {
 
 secret_header_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.ProvisionVmReply.secret_header)
}
inline std::string* ProvisionVmReply::mutable_secret_header() {
  std::string* _s = _internal_mutable_secret_header();
  // @@protoc_insertion_point(field_mutable:trustedowner.ProvisionVmReply.secret_header)
  return _s;
}
inline const std::string& ProvisionVmReply::_internal_secret_header() const {
  return secret_header_.Get();
}
inline void ProvisionVmReply::_internal_set_secret_header(const std::string& value) {
  
  secret_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProvisionVmReply::_internal_mutable_secret_header() {
  
  return secret_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProvisionVmReply::release_secret_header() {
  // @@protoc_insertion_point(field_release:trustedowner.ProvisionVmReply.secret_header)
  return secret_header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProvisionVmReply::set_allocated_secret_header(std::string* secret_header) {
  if (secret_header != nullptr) {
    
  } else {
    
  }
  secret_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    secret_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.ProvisionVmReply.secret_header)
}

// bytes secret_blob = 2;
inline void ProvisionVmReply::clear_secret_blob() {
  secret_blob_.ClearToEmpty();
}
inline const std::string& ProvisionVmReply::secret_blob() const {
  // @@protoc_insertion_point(field_get:trustedowner.ProvisionVmReply.secret_blob)
  return _internal_secret_blob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProvisionVmReply::set_secret_blob(ArgT0&& arg0, ArgT... args) {
 
 secret_blob_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.ProvisionVmReply.secret_blob)
}
inline std::string* ProvisionVmReply::mutable_secret_blob() {
  std::string* _s = _internal_mutable_secret_blob();
  // @@protoc_insertion_point(field_mutable:trustedowner.ProvisionVmReply.secret_blob)
  return _s;
}
inline const std::string& ProvisionVmReply::_internal_secret_blob() const {
  return secret_blob_.Get();
}
inline void ProvisionVmReply::_internal_set_secret_blob(const std::string& value) {
  
  secret_blob_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProvisionVmReply::_internal_mutable_secret_blob() {
  
  return secret_blob_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProvisionVmReply::release_secret_blob() {
  // @@protoc_insertion_point(field_release:trustedowner.ProvisionVmReply.secret_blob)
  return secret_blob_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProvisionVmReply::set_allocated_secret_blob(std::string* secret_blob) {
  if (secret_blob != nullptr) {
    
  } else {
    
  }
  secret_blob_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret_blob,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_blob_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    secret_blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.ProvisionVmReply.secret_blob)
}

// -------------------------------------------------------------------

// GenerateReportForVmRequest

// bytes vm_data = 1;
inline void GenerateReportForVmRequest::clear_vm_data() {
  vm_data_.ClearToEmpty();
}
inline const std::string& GenerateReportForVmRequest::vm_data() const {
  // @@protoc_insertion_point(field_get:trustedowner.GenerateReportForVmRequest.vm_data)
  return _internal_vm_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateReportForVmRequest::set_vm_data(ArgT0&& arg0, ArgT... args) {
 
 vm_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.GenerateReportForVmRequest.vm_data)
}
inline std::string* GenerateReportForVmRequest::mutable_vm_data() {
  std::string* _s = _internal_mutable_vm_data();
  // @@protoc_insertion_point(field_mutable:trustedowner.GenerateReportForVmRequest.vm_data)
  return _s;
}
inline const std::string& GenerateReportForVmRequest::_internal_vm_data() const {
  return vm_data_.Get();
}
inline void GenerateReportForVmRequest::_internal_set_vm_data(const std::string& value) {
  
  vm_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateReportForVmRequest::_internal_mutable_vm_data() {
  
  return vm_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateReportForVmRequest::release_vm_data() {
  // @@protoc_insertion_point(field_release:trustedowner.GenerateReportForVmRequest.vm_data)
  return vm_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateReportForVmRequest::set_allocated_vm_data(std::string* vm_data) {
  if (vm_data != nullptr) {
    
  } else {
    
  }
  vm_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vm_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vm_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vm_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.GenerateReportForVmRequest.vm_data)
}

// bytes vm_data_hmac = 2;
inline void GenerateReportForVmRequest::clear_vm_data_hmac() {
  vm_data_hmac_.ClearToEmpty();
}
inline const std::string& GenerateReportForVmRequest::vm_data_hmac() const {
  // @@protoc_insertion_point(field_get:trustedowner.GenerateReportForVmRequest.vm_data_hmac)
  return _internal_vm_data_hmac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateReportForVmRequest::set_vm_data_hmac(ArgT0&& arg0, ArgT... args) {
 
 vm_data_hmac_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.GenerateReportForVmRequest.vm_data_hmac)
}
inline std::string* GenerateReportForVmRequest::mutable_vm_data_hmac() {
  std::string* _s = _internal_mutable_vm_data_hmac();
  // @@protoc_insertion_point(field_mutable:trustedowner.GenerateReportForVmRequest.vm_data_hmac)
  return _s;
}
inline const std::string& GenerateReportForVmRequest::_internal_vm_data_hmac() const {
  return vm_data_hmac_.Get();
}
inline void GenerateReportForVmRequest::_internal_set_vm_data_hmac(const std::string& value) {
  
  vm_data_hmac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateReportForVmRequest::_internal_mutable_vm_data_hmac() {
  
  return vm_data_hmac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateReportForVmRequest::release_vm_data_hmac() {
  // @@protoc_insertion_point(field_release:trustedowner.GenerateReportForVmRequest.vm_data_hmac)
  return vm_data_hmac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateReportForVmRequest::set_allocated_vm_data_hmac(std::string* vm_data_hmac) {
  if (vm_data_hmac != nullptr) {
    
  } else {
    
  }
  vm_data_hmac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vm_data_hmac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vm_data_hmac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vm_data_hmac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.GenerateReportForVmRequest.vm_data_hmac)
}

// -------------------------------------------------------------------

// GenerateReportForVmReply

// bytes quote = 1;
inline void GenerateReportForVmReply::clear_quote() {
  quote_.ClearToEmpty();
}
inline const std::string& GenerateReportForVmReply::quote() const {
  // @@protoc_insertion_point(field_get:trustedowner.GenerateReportForVmReply.quote)
  return _internal_quote();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateReportForVmReply::set_quote(ArgT0&& arg0, ArgT... args) {
 
 quote_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:trustedowner.GenerateReportForVmReply.quote)
}
inline std::string* GenerateReportForVmReply::mutable_quote() {
  std::string* _s = _internal_mutable_quote();
  // @@protoc_insertion_point(field_mutable:trustedowner.GenerateReportForVmReply.quote)
  return _s;
}
inline const std::string& GenerateReportForVmReply::_internal_quote() const {
  return quote_.Get();
}
inline void GenerateReportForVmReply::_internal_set_quote(const std::string& value) {
  
  quote_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateReportForVmReply::_internal_mutable_quote() {
  
  return quote_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateReportForVmReply::release_quote() {
  // @@protoc_insertion_point(field_release:trustedowner.GenerateReportForVmReply.quote)
  return quote_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateReportForVmReply::set_allocated_quote(std::string* quote) {
  if (quote != nullptr) {
    
  } else {
    
  }
  quote_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quote,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (quote_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    quote_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:trustedowner.GenerateReportForVmReply.quote)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trustedowner

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
